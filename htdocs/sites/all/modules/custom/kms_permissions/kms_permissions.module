<?php

/**
 * Implements hook_menu().
 */
function kms_permissions_menu() {
  $items = array();

  $items['kms-permissions/ajax/load-sids-by-bid'] = array(
    'title' => 'Kms permissions load service ids by bundle id',
    'page callback' => 'kms_permissions_ajax_get_services_by_bids',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['kms-permissions/ajax/user-autocomplete'] = array(
    'title' => 'Kms permissions autocomplete to be used by form element',
    'page callback' => 'kms_permissions_user_autocomplete_callback',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function kms_permissions_ctools_plugin_directory($module, $plugin) {
  // we'll be nice and limit scandir() calls
  if ($module == 'ctools' && $plugin == 'content_types') {
    return 'plugins/content_types';
  }
  if ($module == 'kms_oci_queue') {
    return 'plugins/kms_oci_queue/' . $plugin;
  }
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function kms_permissions_permission() {
  return array(
    'administer kms permissions' => array(
      'title' => t('Administer KMS permissions'),
      'description' => t('Administer KMS permissions '),
    ),
  );
}

function kms_permissions_library() {
  // jQuery Foggy plugin.
  $libraries['jquery.foggy'] = array(
    'title' => 'jQuery Foggy',
    'website' => 'http://nbartlomiej.github.io/foggy/',
    'version' => '1.1',
    'js' => array(
      drupal_get_path('module', 'kms_permissions') . '/js/jquery.foggy.min.js' => array(),
    ),
  );

  return $libraries;
}

/**
 * Implementation of hook_action_info().
 */
function kms_permissions_action_info() {
  return array(
    'kms_permissions_vbo_clone_user_perms' => array(
      'label' => t('Clone permissions (choose target users)'),
      'type' => 'user',
      'configurable' => TRUE,
      'hooks' => array(),
    ),
  );
}

/**
 * Implements hook_views_api().
 */
function kms_permissions_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'kms_permissions') . '/views',
  );
}

/**
* Implements hook_field_widget_info().
*/
function kms_permissions_field_widget_info() {
  return array(
    'kms_applications' => array(
      'label' => t('KMS applications'),
      'field types' => array('list_text'),
      'settings' => array(),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      ),
    ),
    'kms_services' => array(
      'label' => t('KMS services'),
      'field types' => array('list_text'),
      'settings' => array('type' => 'foo'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      ),
    ),
  );
}

/**
* Implements hook_field_widget_settings_form().
*/
function kms_permissions_field_widget_settings_form($field, $instance) {
  $settings = $instance['widget']['settings'];
  if ($instance['widget']['type'] == 'kms_services') {
    $options = kms_permissions_widget_type_options();

    $form['type'] = array(
      '#type' => 'select',
      '#title' => t('Service type'),
      '#default_value' => $settings['type'],
      '#options' => $options,
      '#required' => TRUE,
    );

    return $form;
  }
}

/**
* Implements hook_field_widget_form().
*/
function kms_permissions_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $value_key = key($field['columns']);
  $type = str_replace('options_', '', $instance['widget']['type']);
  $multiple = $field['cardinality'] > 1 || $field['cardinality'] == FIELD_CARDINALITY_UNLIMITED;
  $required = $element['#required'];
  $has_value = isset($items[0][$value_key]);
  $properties = _options_properties($type, $multiple, $required, $has_value);
  $instance_settings = $instance['widget']['settings'];

  switch ($instance['widget']['type']) {
    case 'kms_applications':
    case 'kms_services':
      $default_value = array();

      if (is_array($items)) {
        // Put current field values in
        foreach ($items as $key => $item) {
          $default_value[] = $item['value'];
        }
      }

      $options = kms_permissions_widget_options($instance['widget']['type'], $instance_settings);

      // If required and there is one single option, preselect it.
      if ($required && count($options) == 1) {
        reset($options);
        $default_value = array(key($options));
      }

      // If this is a single-value field, take the first default value, or
      // default to NULL so that the form element is properly recognized as
      // not having a default value.
      if (!$multiple) {
        $default_value = $default_value ? reset($default_value) : NULL;
      }

      $element += array(
        '#type' => $multiple ? 'checkboxes' : 'radios',
        '#title' => ($instance['widget']['type'] == 'kms_applications' ? t('KMS applications') : t('KMS services')),
        '#default_value' => $default_value,
        '#options' => $options
      );
  }


  $element += array(
    '#value_key' => $value_key,
    '#element_validate' => array('options_field_widget_validate'),
    '#properties' => $properties,
  );

  return $element;
}

/**
* Implements hook_field_widget_error().
*/
function kms_permissions_field_widget_error($element, $error) {
  form_error($element, $error['message']);
}

/**
 * Connect to oracle db and get applications or services.
 * @param string $type - type of option list to get
 */
function kms_permissions_widget_options($type = 'kms_services', $instance_settings) {

  switch ($type) {
    case 'kms_services':
      $options = array();
      $type = $instance_settings['type'];

      static $options;

      if (empty($options[$type])) {
        $rows = kms_permissions_get_service_list();
        if (!empty($rows)) {
            foreach ($rows as $row) {
              $html = _kms_permissions_format_item_list_item(
                $row['SERVICEID'],
                $row['SERVICENAME'],
                'webservice'
              );
              $options[$row['TYPENAME']][$row['SERVICEID']] = $html;
            }
        }
      }

      return !empty($options[$type]) ? $options[$type] : array();

    case 'kms_applications';
      $options = array();

      // Connect to default database

        $rows = kms_permissions_get_application_list();
        if (!empty($rows)) {
          foreach ($rows as $row) {
            $html = _kms_permissions_format_item_list_item(
              $row['GROUPID'],
              $row['NAME'],
              'application'
            );
            $options[$row['GROUPID']] = $html;
          }

      }

      return $options;
  }
}

function kms_permissions_get_service_list() {

  $settings = array(
    'kms_oci_conn_user' => variable_get('kms_permissions_conn_user', ''),
    'kms_oci_conn_pass' => variable_get('kms_permissions_conn_pass', ''),
    'kms_oci_conn_host' => variable_get('kms_permissions_conn_host', ''),
    'kms_oci_conn_db' => variable_get('kms_permissions_conn_db', ''),
  );

  $service_data = &drupal_static(__FUNCTION__);

  if (!isset($service_data)) {

    if (kms_oci_get_conn('kms_permissions', $settings)) {
      $query = "SELECT S2.SERVICEID, S2.SERVICENAME, ST.TYPEID, ST.TYPENAME FROM SERVICES2 S2, SERVICETYPES2 ST WHERE S2.TYPEID = ST.TYPEID ORDER BY lower(S2.SERVICENAME) ASC";

      $rows = kms_oci_select($query, array(), 'kms_permissions');

      if (!empty($rows)) {
        array_walk($rows, function($service) use (&$service_data){
          $service_data[$service['SERVICEID']] =  $service;
        });
      }
      else {
        watchdog('kms_permissons', 'Could not read from Oracle', array(), WATCHDOG_ERROR);
      }

      // Close connection
      kms_oci_close_conn('kms_permissions');
    }


  }
  return $service_data;
}

function kms_permissions_get_application_list() {

  $settings = array(
    'kms_oci_conn_user' => variable_get('kms_permissions_conn_user', ''),
    'kms_oci_conn_pass' => variable_get('kms_permissions_conn_pass', ''),
    'kms_oci_conn_host' => variable_get('kms_permissions_conn_host', ''),
    'kms_oci_conn_db' => variable_get('kms_permissions_conn_db', ''),
  );

  $application_data = &drupal_static(__FUNCTION__);

  if (!isset($service_data)) {

    if (kms_oci_get_conn()) {
          $query = "SELECT GROUPID, NAME FROM SMGROUP ORDER BY lower(NAME) ASC";

          $rows = kms_oci_select($query, array());

          if (!empty($rows)) {
            $application_data = $rows;
          }
          else {
            watchdog('kms_permissons', 'Could not read from Oracle', array(), WATCHDOG_ERROR);
          }

          // Close connection
          kms_oci_close_conn();
    }


  }
  return $application_data;
}

/**
 * Format item list used in bundles and users.
 *
 * @param integer $item_id
 *   The ident of the item type.
 * @param $item_name
 *   The name of the item.
 * @param string $item_type
 *   The type of item.
 * @return string
 */
function _kms_permissions_format_item_list_item($item_id, $item_name, $item_type) {
  $html = '';
  $item_name = _kms_permissions_perm_name_render($item_id, $item_name);
  // Get the bundle attached to the item id.
  $nid_sid_arr = _kms_permissions_get_bundles_by_item_id($item_id, $item_type);
  // If the service is not part of a bundle.
  if (empty($nid_sid_arr)) {
    return '<span class="bundle-no-bundle">' . $item_name . '</span>';
  }
  // Start with the name.
  $html .= $item_name . ' ';

  foreach ($nid_sid_arr as $type => $nodes) {
    foreach ($nodes as $nid => $title) {
      $bundle_node = node_load($nid);

      $wrapper = entity_metadata_wrapper('node', $bundle_node);
      if(isset($wrapper->field_colour->value()->field_default_image)){
        $file_uri = $wrapper->field_colour->value()->field_default_image[LANGUAGE_NONE][0]['uri'];
      } else {
        $file_uri = "";
      }

      $html .= '<img src="' . file_create_url($file_uri) . '" alt="' . $type . '" title="'.$title.'">';
    }
  }
  return $html;
}

/**
 * Return array of types in oracle.
 */
function kms_permissions_widget_type_options() {
  // Todo: Make not hardcoded?
  return array('GEO' => 'GEO' , 'WMS' => 'WMS' , 'PLOT' => 'PLOT', 'WFS' => 'WFS', 'WMTS' => 'WMTS', 'WCS' => 'WCS');
}

/**
 * Implements hook_field_formatter_info().
 */
function kms_permissions_field_formatter_info() {
  // custom formatter for bundle reference field
  return array(
    'kms_permissions_bundles_reference' => array(
      'label' => t('Bundle references'),
      'field types' => array('node_reference'),
    ),
    'kms_permissions_service_bundles' => array(
      'label' => t('Service list'),
      'field types' => array('list_text'),
    ),
    'kms_permissions_applications' => array(
      'label' => t('Application list'),
      'field types' => array('list_text'),
    ),

  );
}

/**
 * Implements hook_field_formatter_view().
 */
function kms_permissions_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();

  switch ($display['type']) {

    case 'kms_permissions_bundles_reference':
      $bundle_link = function($nid, $title, $status) {
        $status_class = $status ? 'bundle-active' : 'bundle-inactive';
        if($status == 3) {
          $status_class = 'bundle-default';
        }
        //print('status - '.$status.' on '.$nid.' <br>');
        $bundle_node = node_load($nid);
        $wrapper = entity_metadata_wrapper('node', $bundle_node);

        if(isset($wrapper->field_colour->value()->field_default_image)){
          $file_uri = $wrapper->field_colour->value()->field_default_image[LANGUAGE_NONE][0]['uri'];
        } else {
          $file_uri = "";
        }

        return array(
          '#theme' => 'link',
          '#text' => $nid,
          '#path' => "node/$nid/edit/",
          '#options' => array(
            'attributes' => array('title' => $title),
            'html' => FALSE,
          ),
          '#prefix' => '<span style="background-image:url('.file_create_url($file_uri).');" class="'.$status_class.' '.$nid.'">',
          '#suffix' => '</span>'
        );
      };
      // Query all bundles
      $query = new EntityFieldQuery;
      $result = $query
        ->entityCondition('entity_type', 'node')
        ->entityCondition('bundle', 'access_bundle')
        ->propertyCondition('status', 1)
        ->fieldOrderBy('field_default_bundle', 'value', 'DESC')
        ->execute();

      // We need to load the nodes to get bundle title

      if (isset($result['node'])) {
        $result_nids = array_keys($result['node']);
        $result_node = entity_load('node', $result_nids);
        // Add all enabled bundles to element array
        foreach ($result['node'] as $nid => $node) {
          // Default status = inactive; 0;
          $status_access = 0;

          // Link access status with bundle on ID
          foreach ($items as $item) {
            if ($item['nid'] == $nid && $item['access']) {
              $status_access = 1;
            }
          }

          $element[$nid] = $bundle_link($nid, $result_node[$nid]->title, $status_access);
        }
      }

      break;

      case 'kms_permissions_service_bundles':

          $service_data = kms_permissions_get_service_list();

          foreach ($service_data as $service) {
            foreach ($items as $item) {
              if($item['value']==$service['SERVICEID']) {
                $element[$item['value']]['#markup']  = _kms_permissions_perm_name_render(
                  $service['SERVICEID'],
                  $service['SERVICENAME']
                );
              }
            }
          }

      break;


      case 'kms_permissions_applications':

          $application_data = kms_permissions_get_application_list();

          foreach ($application_data as $application) {
            foreach ($items as $item) {

              if ($item['value'] == $application['GROUPID']) {
                $element[]['#markup'] = _kms_permissions_perm_name_render(
                  $application['GROUPID'],
                  $application['NAME']
                );
              }
            }
          }

      break;
  }

  return $element;
}

/**
 * Implements hook_user_update().
 */
function kms_permissions_user_presave(&$edit, $account, $category) {
  $lang = field_language('user', $edit, 'field_access_bundles');
  // Assign default bundles to a new user
  if ($account->is_new) {
    $array_index = 0;
    foreach (_kms_permissions_get_access_bundles('default') as $bundle_id) {
      // Add Node reference to field field_access_bundle
      $edit['field_access_bundles'][$lang][$array_index]['nid'] = $bundle_id;
      $array_index++;
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function kms_permissions_form_access_bundle_node_form_alter(&$form, &$form_state) {
  $form['#attached']['js'][] = array(
    'data' => array('kms_permissions' => array('form_id' => $form['#form_id'])),
    'type' => 'setting',
  );
  $form['#attached']['js'][] = drupal_get_path('module', 'kms_permissions') .'/js/kms_perms_checkboxes.js';
  $form['#attached']['css'][] = drupal_get_path('module', 'kms_permissions') .'/css/edit_bundles_and_services.css';
//  $form['#attached']['library'][] = array('kms_permissions', 'jquery.foggy');

  $form['actions']['submit']['#submit'][] = 'kms_permissions_access_bundle_update';
  $form['actions']['delete']['#submit'][] = 'kms_permissions_access_bundle_update';

  $form['Legend element'] = array(
      '#title' => t('Bundle Legend'),
      '#markup' => views_embed_view('bundle_legend_header', 'default'),
      '#weight' => 6
    );

  _kms_permissions_common_form_alter($form);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function kms_permissions_form_user_profile_form_alter(&$form, &$form_state) {
  $form['#attached']['js'][] = array(
    'data' => array('kms_permissions' => array('form_id' => $form['#form_id'])),
    'type' => 'setting',
  );
  $form['#attached']['js'][] = drupal_get_path('module', 'kms_permissions') .'/js/kms_perms_checkboxes.js';
  $form['#attached']['css'][] = drupal_get_path('module', 'kms_permissions') .'/css/edit_bundles_and_services.css';

  foreach(_kms_permissions_get_access_bundles('default') as $bid) {

  }
  // Atodo: I let this stay in case of change request. Remove if not needed!
  // Hide default bundle checkboxes.
  //  $access_bundle_options = &$form['field_access_bundles'][$form['field_access_bundles']['#language']]['#options'];
  //  $access_bundle_options = array_diff_key($access_bundle_options, array_flip(_kms_permissions_get_default_bundles()));

  $services_description = array(
    'title' => array(
      '#theme' => 'html_tag',
      '#tag' => 'h3',
      '#value' => t('Services'),
      '#attributes' => array(
        'class' => array('fieldset-title'),
      ),
    ),
    'description' => array(
      '#theme' => 'html_tag',
      '#tag' => 'div',
      '#value' => t('Services that are dependant on the bundles chosen.'),
      '#attributes' => array(
        'class' => array('description'),
      ),
    ),
    'legend' => array(
      '#type' => 'markup',
      '#markup' => views_embed_view('bundle_legend_header', 'default'),
    )
  );

  $form['field_access_bundles'][LANGUAGE_NONE]['#suffix'] = render($services_description);
  $form['field_access_bundles'][LANGUAGE_NONE]['#pre_render'][] = 'kms_permissions_process_access_bundles_form_element';

  _kms_permissions_common_form_alter($form);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function kms_permissions_form_user_register_form_alter(&$form, &$form_state) {
  $form['#attached']['js'][] = array(
    'data' => array('kms_permissions' => array('form_id' => $form['#form_id'])),
    'type' => 'setting',
  );

  $form['#attached']['js'][] = drupal_get_path('module', 'kms_permissions') .'/js/kms_perms_checkboxes.js';
  $form['#attached']['css'][] = drupal_get_path('module', 'kms_permissions') .'/css/edit_bundles_and_services.css';

  $services_description = array(
    'title' => array(
      '#theme' => 'html_tag',
      '#tag' => 'h3',
      '#value' => t('Services'),
      '#attributes' => array(
        'class' => array('fieldset-title'),
      ),
    ),
    'description' => array(
      '#theme' => 'html_tag',
      '#tag' => 'div',
      '#value' => t('Services that are dependant on the bundles chosen.'),
      '#attributes' => array(
        'class' => array('description'),
      ),
    ),
    'legend' => array(
      '#type' => 'markup',
      '#markup' => views_embed_view('bundle_legend_header', 'default'),
    )
  );

  $form['field_access_bundles'][LANGUAGE_NONE]['#suffix'] = render($services_description);
  $form['field_access_bundles'][LANGUAGE_NONE]['#pre_render'][] = 'kms_permissions_process_access_bundles_register_form_element';

  _kms_permissions_common_form_alter($form);
}

/**
 *  Do some common form alter for access node and user profile
 */
function _kms_permissions_common_form_alter(&$form) {

  if (user_access('administer kms permissions'))  {
    // Sort prefedined datacollections alphabetically
    if(isset($form['field_predefined_datacollections'])) {
      $sorted_array = $form['field_predefined_datacollections'][LANGUAGE_NONE]['#options'];
      asort($sorted_array);
      $form['field_predefined_datacollections'][LANGUAGE_NONE]['#options'] = $sorted_array;
    }

    foreach ($form['field_predefined_datacollections'][LANGUAGE_NONE]['#options'] as $key => $value) {
      $form['field_predefined_datacollections'][LANGUAGE_NONE]['#options'][$key] =  _kms_permissions_format_item_list_item($key, $value, 'predefined');
    }

    //Add select all to all webservice tabs
    foreach (kms_permissions_widget_type_options() as $key => $value) {
      $form['select_all_field_'.strtolower($value)] = array(
          '#type' => 'checkbox',
          '#title' => t('Select / Unselect all'),
          '#attributes' => array('onclick' => 'Drupal.behaviors.kms_perms_checkboxes.checkUncheckAll(this, "field-name-field-bundle-webservices-'.strtolower($value).'");'),
      );

      $form['#group_children']['select_all_field_'.strtolower($value)] = 'group_webservices_'.strtolower($value);
    }

    //Add manually select all checkboxed for predefined and application tabs
    $form['select_all_field_predefined'] = array(
        '#type' => 'checkbox',
        '#title' => t('Select / Unselect all'),
        '#attributes' => array('onclick' => 'Drupal.behaviors.kms_perms_checkboxes.checkUncheckAll(this, "field-name-field-predefined-datacollections");'),
    );

    $form['select_all_field_applications'] = array(
        '#type' => 'checkbox',
        '#title' => t('Select / Unselect all'),
        '#attributes' => array('onclick' => 'Drupal.behaviors.kms_perms_checkboxes.checkUncheckAll(this, "field-name-field-applications");'),
    );

    $form['select_all_field_ftp'] = array(
        '#type' => 'checkbox',
        '#title' => t('Select / Unselect all'),
        '#attributes' => array('onclick' => 'Drupal.behaviors.kms_perms_checkboxes.checkUncheckAll(this, "field-name-field-ftp-permissions");'),
    );

    $form['#group_children']['select_all_field_predefined'] = 'group_tab_predefined';
    $form['#group_children']['select_all_field_applications'] = 'group_tab_applications';
    $form['#group_children']['select_all_field_ftp'] = 'group_tab_ftp';
  }
}


function kms_permissions_process_access_bundles_form_element($element) {
  $bids = _kms_permissions_get_access_bundles('default');
  foreach (element_children($element) as $bid) {
    if(in_array($bid, $bids)) {
      $element[$bid]['#attributes']['class'][] = 'default-bundle';
      $element[$bid]['#weight'] = $element[$bid]['#weight'] - 200;
    }
  }

  return $element;
}


function kms_permissions_process_access_bundles_register_form_element($element) {
  $bids = _kms_permissions_get_access_bundles('default');
  foreach (element_children($element) as $bid) {
    if(in_array($bid, $bids)) {
      $element[$bid]['#attributes']['class'][] = 'default-bundle';
      $element[$bid]['#weight'] = $element[$bid]['#weight'] - 200;
      $element[$bid]['#attributes']['checked'][] = 'checked';
    }
  }

  return $element;
}


/**
 * Implements hook_node_presave().
 */
function kms_permissions_node_presave($node) {
  if($node->type != 'access_bundle') {
    return;
  }

  // If the access bundle is new create 'diff' array
  // with all attached permissions.
  if ($node->is_new) {
    $w_new = entity_metadata_wrapper('node', $node);
    $perms = KmsPermsDiff::constructSeparatePerms(
      $w_new,
      $w_new
    );
    // Format permissions in diff array that kms oci queue understands.
    array_walk($perms['new'], function($ids, $type) use (&$diff){
      foreach($ids as $id) {
        $diff[$type]['add'][$id] = $id;
      }
    });
  }
  // If the access bundle is being updated set diff property.
  else {
    $w_original = entity_metadata_wrapper('node', $node->original);
    $w_new = entity_metadata_wrapper('node', $node);
    $diff = KmsPermsDiff::diffSeparatePerms(
      $w_original,
      $w_new
    );
    $bounding_box_original = new KmsPermsBoundingBoxBundle($w_original);
    $bounding_box_new = new KmsPermsBoundingBoxBundle($w_new);
    $bb_data_original = $bounding_box_original->getData();
    $bb_data_new = $bounding_box_new->getData();
    $node->bounding_box_diff = array_diff_assoc($bb_data_new, $bb_data_original);
  }
  // Set permission diff property on access bundle node.
  $node->kms_permissions_diff = $diff;

  $node->update_default_bundle =
    $node->update_bundle = FALSE;

  // Update default bundle when is set as default first time, default state is changed
  $default_new = $default_org = field_get_items('node', $node, 'field_default_bundle');
  if (isset($node->original)) {
    $default_org = field_get_items('node', $node->original, 'field_default_bundle');
  }
  else if ($default_new[0]['value']) {
    $node->update_default_bundle = TRUE;
    return;
  }

  // Set flag to tell submit hook that bundle "default" status has changed
  if ($default_new != $default_org) {
    $node->update_default_bundle = TRUE;
    return;
  }

  // Set flag to tell submit hook that permissions or other settings have changed
  if (isset($node->original)) {
    $fields = array(
      'field_predefined_datacollections',
      'field_applications'
    );

    $fields = array_merge($fields, _kms_permissions_webservice_fields());

    foreach ($fields as $field) {
      if (_kms_permissions_hash_field('node', $node, $field) != _kms_permissions_hash_field('node', $node->original, $field)) {
        $node->update_bundle = TRUE;
        // If bundle is set as default and changes are made update default bundle
        if ($default_new[0]['value']) {
           $node->update_default_bundle = TRUE;
        }
        return;
      }
    }
  }

}

//function kms_permissions_node_load($nodes, $types) {
//  // Atodo skip this until it is fully implemented.
//  return;
//  // Decide whether any of $types are relevant to our purposes.
//  if (in_array('access_bundle', $types)) {
//    // Gather our extra data for each of these nodes.
//    $result = db_query(
//      'SELECT nid, diff FROM {kms_permissions_diff_node} WHERE nid IN(:nids)',
//      array(':nids' => array_keys($nodes))
//    );
//    // Add our extra data to the node objects.
//    foreach ($result as $record) {
//      $nodes[$record->nid]->kms_permissions_diff = unserialize($record->diff);
//    }
//  }
//}

/**
 * Submit callback for bundle update or delete
 */
function kms_permissions_access_bundle_update($form, $form_state) {
  $bundle = $form['#node'];
  $bid = $bundle->nid;
  $default_bundle_is_updated = (bool)$bundle->update_default_bundle;
  $bundle_is_updated = (bool)$bundle->update_bundle;
  $bundle_is_deleted = $form_state['clicked_button']['#id'] == 'edit-delete';
  $action = '';

  if ($default_bundle_is_updated) {
    // If a bundle is set as a default bundle or WAS set as a default bundle, update all users.
    $uids = _kms_permissions_get_all_users();
    $action = KMS_OCI_QUEUE_ACTION_BUNDLE_SAVE;
    if(!empty($uids)) {
      kms_permissions_run_batch('default_bundle_attach_users', $bid, $uids);
    }
  }
  else if ($bundle_is_updated) {
    // When a bundle get updated, find all users related to that bundle, and queue them for updating.
    $uids = _kms_permissions_get_users_by_bid($bid);
    $action = KMS_OCI_QUEUE_ACTION_BUNDLE_SAVE;
    // Clear cached perm filter form at admin/people.
    cache_clear_all(KMS_USER_CACHE_ID_ADMIN_VIEWS_PEOPLE_PERMS_FORM, 'cache');
  }
  elseif($bundle_is_deleted) {
    $uids = _kms_permissions_get_users_by_bid($bid);
    $action = KMS_OCI_QUEUE_ACTION_BUNDLE_DELETE;
  }

  // Only create a job if there are any users using the bundle.
  if (!empty($uids) && !empty($action)) {
    $job_params = array(
      'action' => $action,
      'params' => array(
        'uids' => $uids,
        'bid' => $bid,
        'bundle_diff' => $bundle->kms_permissions_diff,
      ),
    );
    $job_params['action_details'] = format_string(
      'Bundle: "@bundle" saved. Affects @count users.',
      array(
        '@bundle' => $bundle->title,
        '@count' => count($uids),
      )
    );
    KmsOciQueueJob::create($job_params);
    KmsOciQueueJob::create($job_params, 'kms_permissions');
  }

  if (!empty($bundle->bounding_box_diff)) {
    $job_params = array(
      'action' => KMS_OCI_QUEUE_ACTION_BOUNDING_BOX_UPDATE,
      'params' => array(
        'bounding_box_diff' => $bundle->bounding_box_diff,
        'bid' => $bid,
      ),
    );
    $job_params['action_details'] = format_string(
      'Bounding box data for bundle: "@bundle" updated.',
      array(
        '@bundle' => $bundle->title,
      )
    );
    KmsOciQueueJob::create($job_params, 'kms_permissions');
  }

}


function _kms_permissions_get_bundle_perms_by_uid($uid, &$permissions = array(), $options = array()) {
  $options += array(
    'key_prefix' => TRUE,
    'flattened' => FALSE,
  );

  $user = user_load($uid);
  // Get default bundles
  $default = _kms_permissions_get_access_bundles('default');

  // Get users bundles
  $field_access_bundles = field_get_items('user', $user, 'field_access_bundles');

  if (is_array($field_access_bundles)) {
    array_walk($field_access_bundles, function(&$row) {
      $row = $row['nid'];
    });
    $bundles = array_merge($field_access_bundles, $default);
  }
  else {
    $bundles = $default;
  }

  if (!empty($bundles)) {
    $bundles = array_unique($bundles);
    // Get permissions from all bundles
    foreach ($bundles as $bid) {
      _kms_permissions_get_permissions_by_bid($bid, $permissions, $options);
    }
  }
}

/**
 * Return nicely formatted array for oracle inserting.
 */
function _kms_permissions_get_permissions_by_bid($bid, &$permissions = array(), $options = array()) {
  $options += array(
    'key_prefix' => TRUE,
    'flattened' => FALSE,
  );
  $key_prefix = $options['key_prefix'];
  $flattened = $options['flattened'];

  $bundle = node_load($bid);
  // If the bundle does not exist. Do nothing.
  if (!$bundle) {
    return;
  }

  $field_access_userdefined_ranges = field_get_items('node', $bundle, 'field_access_userdefined_ranges');
  if (!empty($field_access_userdefined_ranges)) {
    $field_access_userdefined_ranges = reset($field_access_userdefined_ranges);
  }

  $field_max_download_size = field_get_items('node', $bundle, 'field_max_download_size');
  if (!empty($field_max_download_size)) {
    $field_max_download_size = reset($field_max_download_size);
  }

  // Get all bounding box info
  $bounding_box = array();
  foreach (_kms_permissions_bounding_box_fields() as $value) {
    $box_field = field_get_items('node', $bundle, $value);
    $bounding_box[$value] = $box_field[0]['value'];
  }

  // Predefined datacollections
  $field_predefined_datacollections = field_get_items('node', $bundle, 'field_predefined_datacollections');
  if (!empty($field_predefined_datacollections)) {
    foreach ($field_predefined_datacollections as $predefined) {
      $pd_key = $key_prefix ? 'pd' . $predefined['target_id'] : $predefined['target_id'];
      // If a user has access to userdefined ranges on a product on one bundle, there is always access
      if (isset($permissions['predefined_datacollections'][$pd_key])) {
        $access_userdefined_ranges = ($permissions['predefined_datacollections'][$pd_key]['access_userdefined_ranges'] + $field_access_userdefined_ranges['value'] > 0 ? 1 : 0);
      }
      else {
        $access_userdefined_ranges = $field_access_userdefined_ranges['value'];
      }

      // Only select min/max value if key exists to avoid notices
      if (isset($permissions['predefined_datacollections']) && isset($permissions['predefined_datacollections'][$pd_key])) {
        if ($flattened) {
          $permissions['predefined_datacollections'][$pd_key] = $predefined['target_id'];
        }
        else {
          $permissions['predefined_datacollections'][$pd_key] = array(
            'access_userdefined_ranges' => $access_userdefined_ranges,
            'max_download_size' => max(
              $permissions['predefined_datacollections'][$pd_key]['max_download_size'],
              $field_max_download_size['value']
            ),
            'id' => $predefined['target_id'],
            'MINX' => min($permissions['predefined_datacollections'][$pd_key]['MINX'], $bounding_box['field_bundle_minx']),
            'MINY' => min($permissions['predefined_datacollections'][$pd_key]['MINY'], $bounding_box['field_bundle_miny']),
            'MAXX' => max($permissions['predefined_datacollections'][$pd_key]['MAXX'], $bounding_box['field_bundle_maxx']),
            'MAXY' => max($permissions['predefined_datacollections'][$pd_key]['MAXY'], $bounding_box['field_bundle_maxy']),
            'MAXPIXELWIDTH' => max(
              $permissions['predefined_datacollections'][$pd_key]['MAXPIXELWIDTH'],
              $bounding_box['field_bundle_maxpixelwidth']
            ),
            'MAXPIXELHEIGHT' => max(
              $permissions['predefined_datacollections'][$pd_key]['MAXPIXELHEIGHT'],
              $bounding_box['field_bundle_maxpixelheight']
            ),
            'FEATUREINFO' => '1',
          );
        }
      }
      else {
        if ($flattened) {
          $permissions['predefined_datacollections'][$pd_key] = $predefined['target_id'];
        }
        else {
          $permissions['predefined_datacollections'][$pd_key] = array(
            'access_userdefined_ranges' => $access_userdefined_ranges,
            'max_download_size' => $field_max_download_size['value'],
            'id' => $predefined['target_id'],
            'MINX' => $bounding_box['field_bundle_minx'],
            'MINY' => $bounding_box['field_bundle_miny'],
            'MAXX' => $bounding_box['field_bundle_maxx'],
            'MAXY' => $bounding_box['field_bundle_maxy'],
            'MAXPIXELWIDTH' => $bounding_box['field_bundle_maxpixelwidth'],
            'MAXPIXELHEIGHT' => $bounding_box['field_bundle_maxpixelheight'],
            'FEATUREINFO' => '1',
          );
        }
      }
    }
  }

  // Webservices
  $webservice_fields = _kms_permissions_webservice_fields();
  foreach ($webservice_fields as $webservice_field) {
    $field_services = field_get_items('node', $bundle,  $webservice_field);
    if (!empty($field_services)) {
      foreach ($field_services as $services) {
        $service_key = $key_prefix ? 's' . $services['value'] : $services['value'];
        // If a user has access to userdefined ranges on a product on one bundle, there is always access
        if (isset($permissions['services'][$service_key])) {
          $access_userdefined_ranges = ($permissions['services'][$service_key]['access_userdefined_ranges'] + $field_access_userdefined_ranges['value'] > 0 ? 1 : 0);
        }
        else {
          $access_userdefined_ranges = $field_access_userdefined_ranges['value'];
        }

        // Only select min/max value if key exists to avoid notices
        if (isset($permissions['services']) && isset($permissions['services'][$service_key])) {
          if ($flattened) {
            $permissions['services'][$service_key] = $services['value'];
          }
          else {
            $permissions['services'][$service_key] = array(
              'access_userdefined_ranges' => $access_userdefined_ranges,
              'id' => $services['value'],
              'MINX' => min($permissions['services'][$service_key]['MINX'], $bounding_box['field_bundle_minx']),
              'MINY' => min($permissions['services'][$service_key]['MINY'], $bounding_box['field_bundle_miny']),
              'MAXX' => max($permissions['services'][$service_key]['MAXX'], $bounding_box['field_bundle_maxx']),
              'MAXY' => max($permissions['services'][$service_key]['MAXY'], $bounding_box['field_bundle_maxy']),
              'MAXPIXELWIDTH' => max($permissions['services'][$service_key]['MAXPIXELWIDTH'], $bounding_box['field_bundle_maxpixelwidth']),
              'MAXPIXELHEIGHT' => max($permissions['services'][$service_key]['MAXPIXELHEIGHT'], $bounding_box['field_bundle_maxpixelheight']),
              'FEATUREINFO' => '1',
            );
          }
        }
        else {
          if ($flattened) {
            $permissions['services'][$service_key] = $services['value'];
          }
          else {
            $permissions['services'][$service_key] = array(
              'access_userdefined_ranges' => $access_userdefined_ranges,
              'id' => $services['value'],
              'MINX' => $bounding_box['field_bundle_minx'],
              'MINY' => $bounding_box['field_bundle_miny'],
              'MAXX' => $bounding_box['field_bundle_maxx'],
              'MAXY' => $bounding_box['field_bundle_maxy'],
              'MAXPIXELWIDTH' => $bounding_box['field_bundle_maxpixelwidth'],
              'MAXPIXELHEIGHT' => $bounding_box['field_bundle_maxpixelheight'],
              'FEATUREINFO' => '1',
            );
          }

        }
        if (!$flattened) {
          // We want to know which field the service belongs to in drupal.
          $permissions['services'][$service_key]['field'] = $webservice_field;
        }
      }
    }
  }

  // Applications
  $field_applications = field_get_items('node', $bundle, 'field_applications');
  if (!empty($field_applications)) {
    foreach ($field_applications as $applications) {
      // If a user has access to userdefined ranges on a product on one bundle, there is always access
      if (isset($permissions['applications']['a' . $applications['value']])) {
        $access_userdefined_ranges = ($permissions['applications']['a' . $applications['value']]['access_userdefined_ranges'] + $field_access_userdefined_ranges['value'] > 0 ? 1 : 0);
      }
      else {
        $access_userdefined_ranges = $field_access_userdefined_ranges['value'];
      }
      $ap_key = $key_prefix ? 'a' . $applications['value'] : $applications['value'];
      if ($flattened) {
        $permissions['applications'][$ap_key] = $applications['value'];
      }
      else {
        $permissions['applications'][$ap_key] = array(
          'access_userdefined_ranges' => $access_userdefined_ranges,
          'id' => $applications['value'],
        );
      }
    }
  }

  return $permissions;
}

/**
 * Find all users that have a relation to a given bundle.
 */
function _kms_permissions_get_users_by_bid($bid) {
  $query = new EntityFieldQuery();

  $query->entityCondition('entity_type', 'user')
    ->fieldCondition('field_access_bundles', 'nid', $bid, '=')
    ->addMetaData('account', user_load(1));

  $result = $query->execute();
  $uids = array();

  if ($result) {
    foreach ($result['user'] as $user) {
      $uids[] = $user->uid;
    }
  }
  return $uids;
}

/**
 * Find all users.
 *
 * @param bool $only_active
 *   Only retrieve active users.
 *
 * @return array
 */
function  _kms_permissions_get_all_users($only_active = FALSE) {
  $uids = &drupal_static(__FUNCTION__ . (int) $only_active);
  if (!isset($uids)) {
    $query = db_select('users', 'u')
      ->fields('u', array('uid'));
    $query->condition('uid', 1, '!=');
    if ($only_active) {
      $query->condition('status', 1, '=');
    }
    // For debugging purposes.
  //    ->range(0, 5);
    $result = $query->execute()->fetchCol();
    $uids = $result ? $result : array();
  }
  return $uids;
}

/**
 * Find all default and active bundles.
 */
function _kms_permissions_get_access_bundles($subtype) {

  if($subtype == 'default') {
    $field_info = field_info_instance('node', 'field_default_bundle', 'access_bundle');
    // If field does not exist return empty array.
    if (empty($field_info)) {
      return array();
    }
    $default_value = 1;
  } else {
    $default_value = 0;
  }

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'access_bundle')
    ->propertyCondition('status', 1)
    ->fieldCondition('field_default_bundle', 'value', $default_value, '=')
    ->addMetaData('account', user_load(1)); // Run the query as user 1.

    $result = $query->execute();
    $bids = array();

    if ($result) {
      foreach ($result['node'] as $bundle) {
        $bids[] = $bundle->nid;
      }
    }

  return $bids;
}

/**
 * Get bundles by service id.
 *
 * @param integer $sid
 * @return array
 *   Bundles.
 */
function _kms_permissions_get_bundles_by_service_item($sid) {
 return _kms_permissions_get_bundles_by_item_id($sid, 'webservice');
}

/**
 * Get bundles by ftp id.
 *
 * @param integer $ftp_id
 * @return array
 *   Bundles.
 */
function _kms_permissions_get_bundles_by_ftp_item($ftp_id) {
  return _kms_permissions_get_bundles_by_item_id($ftp_id, 'ftp');
}

/**
 * Find what bundle(s) a given item is included in.
 *
 * @param integer $id
 * @param string $item_type
 * @return array
 *   Bundles.
 */
function _kms_permissions_get_bundles_by_item_id($id, $item_type) {

  $get_bundle_ids = function($sid, $type, $subtype) {
    $bundles = array();

    $item_types = array(
      'webservice' => 'field_bundle_webservices',
      'ftp' => 'field_ftp_permissions',
      'application' => 'field_applications',
      'predefined' => 'field_predefined_datacollections',
    );

    if (empty($item_types[$type])) {
      return array();
    }

    $field_name_pattern = $item_types[$type];

    foreach (_kms_permissions_get_access_bundles($subtype) as $nid) {
      $bundle = node_load($nid);

      foreach ($bundle as $field_name => $field_value) {
        // Only use bundle fields
        if (strpos($field_name, $field_name_pattern) !== FALSE) {
          if (!empty($field_value)) {
            // Search for a match
            foreach ($field_value['und'] as $service_id) {

              if($type =='predefined'){
                if ($service_id['target_id'] == $sid) {
                  $bundles[$subtype][$nid] = $bundle->title;
                }
              } else {
                if ($service_id['value'] == $sid) {
                 $bundles[$subtype][$nid] = $bundle->title;
                }
              }
            }
          }
        }
      }
    }

    return $bundles;
  };

  $nid_sid_arr = array();
  switch ($item_type) {
    case 'webservice':
      $nid_sid_arr = array_merge(
        $get_bundle_ids($id, 'webservice', 'default'),
        $get_bundle_ids($id, 'webservice', 'custom')
      ) ;
    break;

    case 'ftp':
      $nid_sid_arr = array_merge(
        $get_bundle_ids($id, 'ftp', 'default'),
        $get_bundle_ids($id, 'ftp', 'custom')
      );
    break;

    case 'application':
      $nid_sid_arr = array_merge(
        $get_bundle_ids($id, 'application', 'default'),
        $get_bundle_ids($id, 'application', 'custom')
      );
    break;

    case 'predefined':
      $nid_sid_arr = array_merge(
        $get_bundle_ids($id, 'predefined', 'default'),
        $get_bundle_ids($id, 'predefined', 'custom')
      );
    break;
  }

  return $nid_sid_arr;
}

function _kms_permissions_get_services_by_bid($bid) {
  $permissions = $ftp_permissions = $sids = array();
   _kms_permissions_get_permissions_by_bid($bid, $permissions);
   _kms_permissions_ftp_get_permissions_by_bid($bid, $ftp_permissions);
  if(!empty($permissions['services']) && is_array($permissions['services'])) {
    array_walk($permissions['services'], function($v) use(&$sids) {
      $sids['webservices'][] = $v['id'];
    });
  }
  if(!empty($permissions['applications']) && is_array($permissions['applications'])) {
    array_walk($permissions['applications'], function($v) use(&$sids) {
      $sids['tab-applications'][] = $v['id'];
    });
  }

  if(!empty($permissions['predefined_datacollections']) && is_array($permissions['predefined_datacollections'])) {
    array_walk($permissions['predefined_datacollections'], function($v) use(&$sids) {
      $sids['tab-predefined'][] = $v['id'];
    });
  }

  if(!empty($ftp_permissions['ftp']) && is_array($ftp_permissions['ftp'])) {
    array_walk($ftp_permissions['ftp'], function($v) use(&$sids) {
      $sids['tab-ftp'][] = $v['id'];
    });
  }
  return $sids;
}

function _kms_permissions_get_services_by_bids($bids) {
  $sids = array();
  array_walk($bids, function($bid) use (&$sids){
    $sids = array_merge_recursive($sids, _kms_permissions_get_services_by_bid($bid));
  });
  return $sids;
}

function kms_permissions_ajax_get_services_by_bids() {
  $bids = !empty($_POST['bids']) ? $_POST['bids'] : array();
  $json = array('sids' => _kms_permissions_get_services_by_bids($bids));
  drupal_json_output($json);
  exit;
}

/**
* Implementation of hook_node_access_records().
*/
function kms_permissions_node_access_records($node) {
  $grants = array();
  // Should this code be here?
  if ($node->type == 'access_bundle') {
    $wnode = entity_metadata_wrapper('node', $node);
    if ($wnode->field_predefined_datacollections->value()) {
      foreach ($wnode->field_predefined_datacollections->value() as $prod) {
        // Update node access for all related products
        node_access_acquire_grants($prod, TRUE);
      }
    }
    return $grants;
  }

  if ($node->type == 'product_display') {
    $grants[] = array(
      'realm' => 'kms_permissions_access',
      'gid' => $node->nid,
      'grant_view' => $node->status,
      'grant_update' => 0,
      'grant_delete' => 0,
      'priority' => 1,
    );
  }

  return $grants;
}

/**
* Implements hook_node_grants().
*/
function kms_permissions_node_grants($account, $op) {
  $perms = _kms_permissions_get_all_permissions_by_uid(
    $account->uid,
    array(
      'key_prefix' => FALSE,
      'flattened' => TRUE,
    )
  );

  $grants = array();
  if (isset($perms['predefined_datacollections'])) {
    $grants['kms_permissions_access'] = $perms['predefined_datacollections'];
  }

  if (!empty($grants)) {
    return $grants;
  }
}

/**
 * Compare fields.
 */
function _kms_permissions_hash_field($entity_type, $entity, $field_name) {
  $hash = '';
  $field_values = field_get_items($entity_type, $entity, $field_name);

  if ($field_values) {
    foreach ($field_values as $field_value) {
      if (isset($field_value['target_id'])) {
        $hash .= $field_value['target_id'];
      }
      else if (isset($field_value['value'])) {
        $hash .= $field_value['value'];
      }
    }
  }

  $hash = md5($hash);
  return $hash;
}

/**
 * Wrapper to retrieve all services:webservices, predefined collections, applications and ftp fieldnames.
 */
function _kms_permissions_service_fields() {
  $fields = array();
  $fields = array_merge(
    _kms_permissions_webservice_fields(),
    _kms_permissions_extra_service_fields()
  );

  return $fields;
}

/**
 * Retrieve webservice fieldnames.
 * Todo: make smarter
 */
function _kms_permissions_webservice_fields() {
  $fields = array();
  $types = kms_permissions_widget_type_options();
  foreach ($types as $type) {
    $fields[] = 'field_bundle_webservices_' . strtolower($type);
  }

  return $fields;
}

/**
 * Retrieve extra service fieldnames.
 */
function _kms_permissions_extra_service_fields() {
  $fields = array();
  $fields[] = 'field_predefined_datacollections';
  $fields[] = 'field_applications';
  $fields[] = 'field_ftp_permissions';

  return $fields;
}

/**
 * VBO add access bundle form.
 *
 * @atodo comment this.
 * @param array $context
 *   VBO context.
 *
 * @return [type]
*/
function kms_permissions_vbo_clone_user_perms_form($context) {
  $form['source_username'] = array(
    '#type' => 'textfield',
    '#title' => t('Choose source user.'),
    '#description' => t('You have choosen target users. Now choose user to clone from.'),
    // The autocomplete path is provided in hook_menu in ajax_example.module.
    '#autocomplete_path' => 'kms-permissions/ajax/user-autocomplete',
  );

  return $form;
}

/**
 * VBO add access bundle form submit.
 *
 * @atodo comment this.
 * @param array $form
 *   Drupal form array.
 * @param array $form_state
 *   Drupal form state array.
 *
 * @return array
 */
function kms_permissions_vbo_clone_user_perms_submit($form, $form_state) {
//  $uids = array_filter($form_state['selection']);
//  if ($form_state['select_all_pages']) {
//    $uids = _kms_permissions_get_all_users();
//  }
  return array(
    'source_username' => $form_state['values']['source_username'],
//    'uids' => $uids,
  );
}

/**
 * VBO add access bundles operations.
 *
 * @atodo comment this.
 * @param object $account
 *   Drupal user object.
 * @param array $context
 *   VBO context.
 *
 * @return void
 */
function kms_permissions_vbo_clone_user_perms(&$account, $context = array()) {
  $uids_var_key = 'kms_permissions_vbo_clone_user_perms_uids';
  $source_account = user_load_by_name(check_plain($context['source_username']));
  if(!$source_account) {
    return;
  }

  if ($context['progress']['current'] == 1) {
    variable_del($uids_var_key);
  }

  // Get processed uids.
  $uids = variable_get($uids_var_key, array());
  // Add current uid to uids variable.
  $uids[] = $context['user']->uid;
  variable_set($uids_var_key, $uids);

  kms_permissions_clone_perms($source_account, $context['user']);
  if ($context['progress']['current'] == $context['progress']['total']) {
    kms_permissions_vbo_clone_user_perms_finished($source_account, $context);
  }
}

/**
 * @param object $source_account
 *   Drupal user object to clone from.
 * @param array $context
 *   VBO context. We pass uids through that.
 */
function kms_permissions_vbo_clone_user_perms_finished($source_account, $context) {
  $uids = variable_get('kms_permissions_vbo_clone_user_perms_uids', array());

  if (empty($uids)) {
    return;
  }

  $user_count = count($uids);

  $job_params = array(
    'action' => KMS_OCI_QUEUE_ACTION_CLONE_USER_PERMS,
    'action_details' => format_string(
      'Cloning user permissions from: @source_user. Affects @user_count.',
      array(
        '@source_user' => $source_account->name,
        '@user_count' => $user_count,
      )
    ),
    'params' => array(
      'source_uid' => $source_account->uid,
      'uids' => $uids,
    ),
  );

  $jobs[] = KmsOciQueueJob::create($job_params);
  $jobs[] = KmsOciQueueJob::create($job_params, 'kms_permissions');
  // If we are processing under fifty users use a job group.
  if (count($uids) < 300) {
    $job_group = new KmsOciQueueJobGroup();
    $job_group->add($jobs);
  }

}

/**
 * Clone permissions internally from a source user to a target user.
 *
 * @param $source_account
 *   The user to clone permissions from.
 * @param $target_account
 *   The user to clone permissions to.
 * @param bool $reset
 *   Should the permissons be wiped on target user before cloning?
 */
function kms_permissions_clone_perms($source_account, $target_account, $reset = TRUE) {
  $source = entity_metadata_wrapper('user', $source_account);
  $target = entity_metadata_wrapper('user', $target_account);

  if($reset){
    $target->field_access_bundles = NULL;
    foreach(_kms_permissions_service_fields() as $field){
      $target->$field = NULL;
    }
    $target->save();
  }

  $target->field_access_bundles->set($source->field_access_bundles->value());
  foreach(_kms_permissions_service_fields() as $field){
    $target->$field->set($source->$field->value());
  }
  $target->save();
}

/**
 * Form field autocomplete callback for selecting user.
 *
 * @param string $string
 *   Search key.
 */
function kms_permissions_user_autocomplete_callback($string = "") {
  $matches = array();
  if ($string) {
    $result = db_select('users')
      ->fields('users', array('name', 'uid'))
      ->condition('name', db_like($string) . '%', 'LIKE')
      ->range(0, 10)
      ->execute();
    foreach ($result as $user) {
      $matches[$user->name] = check_plain($user->name) . " (uid=$user->uid)";
    }
  }

  drupal_json_output($matches);
}

function kms_permissions_form_views_exposed_form_alter(&$form, &$form_state, $form_id) {
  global $user;

  switch ($form['#id']) {
    case 'views-exposed-form-admin-views-user-system-1':
      foreach ($form['field_user_type_tid']['#options'] as $term_key => $term) {
        // Check if this isn't the 'ANY' option
        if($term_key !== 'All') {
          // Check if this is a child by looking for '--' as first char in string
          $term_value = reset($term->option);
          if($term_value[0] == '-' && $term_value[1] == '-') {
            unset($form['field_user_type_tid']['#options'][$term_key]);
          }
        }
      }
      break;
    case 'views-exposed-form-product-list-default':
      $perms = _kms_permissions_get_all_permissions_by_uid(
        $user->uid,
        array(
          'key_prefix' => FALSE,
          'flattened' => TRUE,
        )
      );

      $query = db_select('taxonomy_index', 'ti');
      $query->join('taxonomy_term_data', 'ttd', 'ttd.tid=ti.tid');
      $query->fields('ttd');
      $query->condition('ttd.vid', 10, '=');

      if (isset($perms['predefined_datacollections'])) {
        $query->condition('ti.nid', $perms['predefined_datacollections'], 'IN');
      }

      $result = $query->execute()->fetchAllAssoc('tid');

      $form['field_korttype_tid_1']['#options'] = array('All' => '- Alle -');
      array_walk($result, function($data, $tid) use (&$form) {
        $form['field_korttype_tid_1']['#options'][$tid] = $data->name;
      });
      break;
  }

}

/**
 * A simple batch execution wrapper.
 *
 * @param string $type
 */
function kms_permissions_run_batch($type) {
  $args = func_get_args();
  unset($args[0]);
  $args = array_values($args);

  switch($type) {
    case 'default_bundle_attach_users':
      list($bid, $uids) = $args;
      $operations = array();
      $user_count = count($uids);
      $chunk_size = 500;
      $chunks = array_chunk($uids, $chunk_size);

      array_walk($chunks, function($uids) use (&$operations, $bid, $user_count, $chunk_size){
        $operations[] = array(
          'kms_permissions_batch_default_bundle_attach_users',
          array($bid, $uids, $user_count, $chunk_size)
        );
      });

      $batch = array(
        'title' => t('Processing users'),
        'operations' => $operations,
        'init_message' => t('Starting process...'),
//      'progress_message' => t('Processed @current out of @total.'),
        'error_message' => t('An error occurred during processing'),
        'finished' => "kms_permissions_batch_default_bundle_attach_users_finished",
        'file' => drupal_get_path('module', 'kms_permissions') . '/kms_permissions.batch.inc',
         'progressive' => FALSE
      );
      break;
  }

  batch_set($batch);
  background_batch_process_batch();

}

/**
 * Get all users that has specified separate services.
 *
 * @param array $services
 *   Ex.: array('field_bundle_webservices_geo' => array(1, 4218, 4458), 'field_bundle_webservices_wms' => array(1614))
 * @return array
 *   User ids.
 */
function _kms_permissions_get_uids_by_separate_services($services) {
  $users = array();

  array_walk($services, function ($sids, $field) use(&$users) {
    $sids = $sids[LANGUAGE_NONE];
    $query = db_select('users', 'u');
    $join_conditions[] = $field .'.entity_id = u.uid';
    $join_conditions[] = $field . ".entity_type = 'user'";
    $query->leftJoin('field_data_' . $field, $field, implode(' AND ', $join_conditions));
    $query->addField($field, sprintf('%s_value', $field), 'sid');
    $query->addField($field, 'entity_id', 'uid');
    $query->condition(sprintf('%s.%s_value', $field, $field), $sids, 'IN');
    $result = $query->execute();

    while($row = $result->fetchAssoc()) {
      $uid = $row['uid'];
      $sid = $row['sid'];
      if(empty($users[$uid])) {
        $users[$uid] = array($sid);
      }
      else {
        $users[$uid] = array_merge($users[$uid], array($sid));
      }
    }

  });

  return $users;
}

/**
 * Get all users that has bundles containing specified services.
 *
 * @param array $services
 *   Ex.: array('field_bundle_webservices_geo' => array(1, 4218, 4458), 'field_bundle_webservices_wms' => array(1614))
 * @return array
 *   User ids.
 */
function _kms_permissions_get_uids_by_bundle_services($services) {
  $users = array();

  foreach($services as $field => $sids) {
    $sids = $sids[LANGUAGE_NONE];
    $query = db_select('users', 'u');
    $query->rightJoin(
      'field_data_' . $field,
      $field,
      $field .'.entity_id = u.uid AND ' . sprintf("%s.bundle = 'access_bundle'", $field)
    );
    $ab_alias = 'ab_' . $field;
    $query->rightJoin(
      'field_data_field_access_bundles',
      $ab_alias,
      sprintf('%s.field_access_bundles_nid = %s.entity_id', $ab_alias, $field)
    );
    $query->addField($field, sprintf('%s_value', $field), 'sid');
    $query->addField($ab_alias, 'entity_id', 'uid');
    $query->condition(sprintf('%s.%s_value', $field, $field), $sids, 'IN');
    $result = $query->execute();
    while($row = $result->fetchAssoc()) {
      $uid = $row['uid'];
      $sid = $row['sid'];
      if(empty($users[$uid])) {
        $users[$uid] = array($sid);
      }
      else {
        $users[$uid] = array_merge($users[$uid], array($sid));
      }
    }
  }

  return $users;
}

/**
 * @param array $sids
 * @return array
 *   Bundle ids (nids).
 */
function _kms_permissions_get_bundles_by_sids($sids) {
  $bids = array();
  if(!empty($sids)) {
    foreach($sids as $sid) {
      $bundles = _kms_permissions_get_bundles_by_service_item($sid);
      if (empty($bundles)) {
        continue;
      }
      array_walk($bundles, function($bundle) use(&$bids) {
        $bids = array_merge($bids, array_keys($bundle));
      });
    }
  }
  return array_unique($bids);
}

/**
 * Get User ids by bundle ids (nids).
 *
 * @param array $bids
 *   Bundle ids (nids).
 * @return array
 */
function _kms_permissions_get_uids_by_bids($bids) {
  $query = db_select('field_data_field_access_bundles', 'ab');
  $query->fields('ab', array('entity_id'));
  $query->condition('ab.field_access_bundles_nid', $bids, 'IN');
  $result = $query->execute();
  return array_keys($result->fetchAllKeyed());
}

/**
 * Get separate services from specified user id.
 *
 * @param int $uid
 *   Drupal user id.
 * @return array
 *   Service ids.
 */
function _kms_permissions_get_separate_webservices_by_uid($uid) {
  $services = array();
  $user = user_load($uid);
  if (!$user) {
    return $services;
  }
  $uw = entity_metadata_wrapper('user', $user);
  foreach(_kms_permissions_webservice_fields() as $field) {
    $sids = $uw->$field->value();
    if (!empty($sids)) {
      array_walk($sids, function($sid) use (&$services) {
        $services[$sid] = $sid;
      });
    }
  }
  return $services;
}

/**
 * Get separate applications by user id.
 *
 * @param int $uid
 *   Drupal user id.
 * @return array
 *   Application ids.
 */
function _kms_permissions_get_separate_applications_by_uid($uid) {
  $applications = array();
  $user = user_load($uid);
  if (!$user) {
    return $applications;
  }
  $uw = entity_metadata_wrapper('user', $user);
  $ids = $uw->field_applications->value();
  if (!empty($ids)) {
    array_walk($ids, function($sid) use (&$applications) {
      $applications[$sid] = $sid;
    });
  }
  return $applications;
}

/**
 * Get separate predefined data collections by user id.
 *
 * @param int $uid
 *   Drupal user id.
 * @return array
 *   Predefined data collection ids.
 */
function _kms_permissions_get_separate_predefined_datacollections_by_uid($uid) {
  $predefined_datacollections = array();
  $user = user_load($uid);
  if (!$user) {
    return $predefined_datacollections;
  }
  $uw = entity_metadata_wrapper('user', $user);
  $ids = $uw->field_predefined_datacollections->raw();
  if (!empty($ids)) {
    array_walk($ids, function($id) use (&$predefined_datacollections) {
      $predefined_datacollections[$id] = $id;
    });
  }
  return $predefined_datacollections;
}

/**
 * Return known boundary box fields.
 *
 * @return array
 */
function _kms_permissions_bounding_box_fields() {
  return array(
    'MINX' => 'field_bundle_minx',
    'MINY' => 'field_bundle_miny',
    'MAXX' => 'field_bundle_maxx',
    'MAXY' => 'field_bundle_maxy',
    'MAXPIXELWIDTH' => 'field_bundle_maxpixelwidth',
    'MAXPIXELHEIGHT' => 'field_bundle_maxpixelheight',
  );
}

/**
 * Return node id(s) of default access bundles.
 *
 * @return array
 *   Node ids.
 */
function _kms_permissions_get_default_bundles() {
  $bids = &drupal_static(__FUNCTION__);
  if (!isset($bids)) {
    $query = new EntityFieldQuery();
    $query
      ->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'access_bundle')
      ->fieldCondition('field_default_bundle', 'value', 1, '=')
      ->propertyCondition('status', 1)
      ->propertyOrderBy('nid')
      ->addMetaData('account', user_load(1))
      ->execute();
    $result = $query->execute();
    if(!empty($result['node'])){
      return array_keys($result['node']);
    }
  }

  return !empty($bids) ? $bids : array();
}

function _kms_permissions_get_non_default_bundles() {
  $bids = &drupal_static(__FUNCTION__);
  if (!isset($bids)) {
    $query = new EntityFieldQuery();
    $query
      ->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'access_bundle')
      ->fieldCondition('field_default_bundle', 'value', 0, '=')
      ->propertyCondition('status', 1)
      ->propertyOrderBy('nid')
      ->addMetaData('account', user_load(1))
      ->execute();
    $result = $query->execute();
    $bids = isset($result['node']) ? array_keys($result['node']) : array();
  }

  return $bids;
}

/**
 * Get the bounding box data of the oldest default bundle created.
 *
 * @return array
 *   Bounding box data.
 */
function _kms_permissions_get_default_bundle_bounding_box_data() {
  $data = array();
  $default_bundles = _kms_permissions_get_default_bundles();
  if (!empty($default_bundles)) {
    $bounding_box = new KmsPermsBoundingBoxBundle($default_bundles[0]);
    $bounding_box_data = $bounding_box->getData();
    if (!empty($bounding_box_data)) {
      $data = $bounding_box_data;
    }
  }
  return $data;
}

/**
 * Get separate permissions from a specified user.
 *
 * @param int $uid
 *   Drupal user id.
 * @param array $perms
 *   The golden kms permissions permission array. Passed by ref.
 * @Atodo Implement all separate perms.
 */
function _kms_permissions_get_separate_perms_by_uid($uid, &$perms, $options = array()) {
  $options += array(
    'key_prefix' => TRUE,
    'flattened' => FALSE,
  );

  // Get all service ids.
  $separate_services = _kms_permissions_get_separate_webservices_by_uid($uid);
  // Atodo: Consider if this is the right way:
  // Atodo: If no default bounding box data is found don't add separate services.
  $bounding_box_data = _kms_permissions_get_default_bundle_bounding_box_data();
  if (!empty($bounding_box_data)) {
    // If services key is not created yet - do it.
    if (empty($perms) || empty($perms['services'])) {
      $perms['services'] = array();
    }
    array_walk(
      $separate_services,
      function($id) use (&$perms, $bounding_box_data, $options) {
        $key = $options['key_prefix'] ? 's' . $id : $id;
        // If we do not have service id in our services array yet
        // create it and attach boundary box data.
        if (empty($perms['services'][$key])) {
          if ($options['flattened']) {
            $perms['services'][$key] = $id;
          }
          else {
            $perms['services'][$key] = array('id' => $id);
            $perms['services'][$key] += $bounding_box_data;
          }
        }
      }
    );
  }
  // Get all application ids.
  $separate_applications = _kms_permissions_get_separate_applications_by_uid($uid);
  if (empty($perms) || empty($perms['applications'])) {
    $perms['applications'] = array();
  }
  array_walk(
    $separate_applications,
    function($id) use (&$perms, $options) {
      $key = $options['key_prefix'] ? 'a' . $id : $id;
      // If we do not have application id
      // in our applications array yet create it.
      if (empty($perms['applications'][$key])) {
        if ($options['flattened']) {
          $perms['applications'][$key] = $id;
        }
        else {
          $perms['applications'][$key] = array('id' => $id);
        }
      }
    }
  );
  // Get all application ids.
  $separate_predefined_datacollections = _kms_permissions_get_separate_predefined_datacollections_by_uid($uid);
  if (empty($perms) || empty($perms['predefined_datacollections'])) {
    $perms['predefined_datacollections'] = array();
  }
  array_walk(
    $separate_predefined_datacollections,
    function($id) use (&$perms, $options) {
      $key = $options['key_prefix'] ? 'pd' . $id : $id;
      // If we do not have application id
      // in our applications array yet create it.
      if (empty($perms['predefined_datacollections'][$key])) {
        if ($options['flattened']) {
          $perms['predefined_datacollections'][$key] = $id;
        }
        else {
          $perms['predefined_datacollections'][$key] = array('id' => $id);
        }
      }
    }
  );
}

/**
 * Return array that reflects relations
 *   between Drupal and Oracle data permission wise.
 *
 * @return array
 *   Data relations array.
 */
function _kms_permissions_perms_oracle_relations() {
  return array(
    'services' => array(
      'table' => 'USERRESTRICTIONS2',
      'cid' => 'kms_permissions',
      'default_values' => array(
        'MINX' => '',
        'MINY' => '',
        'MAXX' => '',
        'MAXY' => '',
        'MAXPIXELWIDTH' => '',
        'MAXPIXELHEIGHT' => '',
        'FEATUREINFO' => '',
      )
    ),
    'applications' => array(
      'table' => 'SMUSERGROUP',
      'cid' => 'default',
      'default_values' => array(
        'USERID' => '',
        'GROUPID' => '',
      )
    ),
  );
}

/**
 * Attach default bundles to a user.
 *
 * @param integer $uid
 * @param array $bids
 */
function _kms_permissions_attach_default_bundles_to_user($uid, $bids) {
  if (empty($uid) || empty($bids)) {
    return;
  }
  // If only one bundle id arrayify it.
  if (intval($bids)) {
    $bids = array($bids);
  }
  // Row data needed for creating default bundle rows.
  $row_data = array(
    'entity_type' => 'user',
    'bundle' => 'user',
    'language' => LANGUAGE_NONE,
    'entity_id' => $uid,
    'revision_id' => $uid,
  );
  // Attach bundles to user.
  foreach ($bids as $def_bundle) {
    $row_data['field_access_bundles_nid'] = $def_bundle;
    $tables = array(
      'field_data_field_access_bundles',
      'field_revision_field_access_bundles',
    );
    // Process field data table and field revision table.
    array_walk($tables, function($table) use ($row_data) {
      // Check if a row is already existing in the table.
      $query = db_select($table, 'f')
        ->fields('f', array('entity_id'));
      foreach($row_data as $k => $v) {
        $query->condition("f.$k", $v, '=');
      }
      $result = $query->execute()->fetchField();
      // If a row does not exist with the default bundle create one.
      if ($result === FALSE) {
        // First find next available delta.
        $query = db_select($table, 'f');
        $query->addExpression('MAX(delta) + 1');
        foreach($row_data as $k => $v) {
          if (in_array($k, array('language', 'field_access_bundles_nid'))) {
            continue;
          }
          $query->condition("f.$k", $v, '=');
        }
        $result = $query->execute()->fetchField();
        // Insert new default bundle row with the new delta.
        $row_data['delta'] = !is_null($result) ? $result : 0;
        db_insert($table)
          ->fields($row_data)
          ->execute();
      }
    });
  }
}

/**
 * Lookup service in default bundles.
 *
 * @param integer $sid
 *   Service id.
 * @return bool
 *   Is service in a default bundle.
 */
function kms_permissions_is_service_in_default_bundle($sid) {
  $bids = _kms_permissions_get_bundles_by_sids(array($sid));
  $bids_default = _kms_permissions_get_default_bundles();
  $matches = array_intersect($bids_default, $bids);
  return !empty($matches);
}

/**
 * Get the ids of the bundles attached to a user.
 *
 * @param integer $uid
 * @return array
 *   Bundle ids.
 */
function kms_permissions_get_bids_by_uid($uid, $ignore_def_bundles = FALSE) {
  $query = db_select('field_data_field_access_bundles', 'fab')
    ->fields('fab', array('field_access_bundles_nid'))
    ->condition('entity_id', $uid, '=');
  $result = $query->execute()->fetchCol();
  if ($result) {
    if ($ignore_def_bundles) {
      return array_diff($result, _kms_permissions_get_default_bundles());
    }
    return $result;
  }
  return array();
}

/**
 * Get bounding box data of a given service id.
 *
 * @param mixed $sid
 *   Service id. Integer or FALSE.
 * @return array
 *   Bounding box data.
 */
function kms_permissions_get_service_bounding_box($sid = FALSE) {
  $bundles = $sid ? _kms_permissions_get_bundles_by_service_item($sid) : array();
  // If no bundle matches use default bundle(s).
  if (empty($bundles)) {
    $def_bundles = _kms_permissions_get_default_bundles();
    if (!empty($def_bundles)) {
      $bundles = array(
        'default' => array_combine($def_bundles, $def_bundles),
      );
    }
    else {
      $bundles = array(
        'default' => array(),
      );
    }

  }

  $bounding_box_data = new KmsPermsBoundingBoxData();
  $boundary_rules = $bounding_box_data->getBoundaryRules();

  // Get all bounding box info
  $bounding_box = $last_values = array();
  array_walk($bundles, function($bundle_ids) use ($boundary_rules, &$bounding_box, &$last_values) {
    foreach(array_keys($bundle_ids) as $bid) {
      $bundle_node = node_load($bid);
      foreach (_kms_permissions_bounding_box_fields() as $field) {
        $box_field = field_get_items('node', $bundle_node, $field);
        $field = str_replace('field_bundle_', '', $field);
        $value = (int) $box_field[0]['value'];
        if (
          empty($last_values[$field])
          || ($boundary_rules[$field] == 'min' && $value < $last_values[$field])
          || ($boundary_rules[$field] == 'max' && $value > $last_values[$field])
        ) {
          $bounding_box[$field] = $value;
        }
        $last_values[$field] = $value;
      }
    }

  });
  return $bounding_box;
}

/**
 * Get service ids by service type.
 *
 * Please note that the function uses temporary cache.
 * Clear it to be sure of having updated data.
 *
 * @param string $type
 *   The type of service.
 * @return array
 *   array of ids.
 */
function kms_permissions_get_service_ids_by_type($type) {
  $ids = &drupal_static(__FUNCTION__);
  if (!isset($ids)) {
    if ($cache = cache_get(__FUNCTION__)) {
      $ids = $cache->data;
    }
    else {
      $ids = array();
      $type = strtolower($type);
      $service_list = kms_permissions_get_service_list();
      if (!empty($service_list)) {
        array_walk($service_list, function($service) use ($type, &$ids) {
          if (strtolower($service['TYPENAME']) == $type) {
            $ids[$type][] = $service['SERVICEID'];
          }
        });
        // Store cache for 2 hours.
        cache_set(__FUNCTION__, $ids, 'cache', time() + 120);
      }
    }
  }

  return !empty($ids[$type]) ? $ids[$type] : array();
}

/**
 * Render permission name.
 *
 * @param string $perm_id
 *   The identifier of the permission.
 * @param string $perm_name
 *   The name of the permis
 * @return string
 */
function _kms_permissions_perm_name_render($perm_id, $perm_name) {
  return sprintf('<span title="%s">%s</span>', $perm_id, $perm_name);
}

/**
 * Create the postgres views that are mimicking the Oracle counterparts.
 */
function _kms_permissions_create_views_n_functions() {
  $file = sprintf(
    "%s/%s/%s/%s",
    DRUPAL_ROOT,
    drupal_get_path('module', 'kms_permissions'),
    'includes',
    'db_views_n_functions.sql'
  );
  $handle = fopen($file, "r");
  $sql = fread($handle, filesize($file));
  fclose($handle);
  db_query($sql);
}

/**
 * Get both bundle and separate permissions for a user.
 *
 * @param integer $uid
 * @param array $options
 * @return array
 */
function _kms_permissions_get_all_permissions_by_uid($uid, $options = array()) {
  static $user_perm_cache;

  $options += array(
    'key_prefix' => TRUE,
    'flattened' => FALSE,
  );

  $user_key = serialize(array_merge(array($uid), $options));
  if (!empty($user_perm_cache[$user_key])) {
    return $user_perm_cache[$user_key];
  }

  $perms = array();

  _kms_permissions_get_bundle_perms_by_uid($uid, $perms, $options);
  _kms_permissions_get_separate_perms_by_uid($uid, $perms, $options);

  $user_perm_cache[$user_key] = $perms;

  return $perms;
}