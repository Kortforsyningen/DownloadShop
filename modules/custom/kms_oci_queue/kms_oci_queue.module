<?php
/**
 * @file
 * kms_oci_queue.module
 * Handle query queues.
 *
 * @author Mikkel Jakobsen <mikkel@adapt.dk>
 */

define('KMS_OCI_QUEUE_PREFIX', 'kms_oci_queue');
define('KMS_OCI_QUEUE_ENGINE_ROOT_URI', 'public://' . KMS_OCI_QUEUE_PREFIX);
define('KMS_OCI_QUEUE_ENGINE_DIR_JOBS', 'jobs');
define('KMS_OCI_QUEUE_ENGINE_DIR_JOBS_PROCESSED', 'jobs_processed');
define('KMS_OCI_QUEUE_ACTION_USER_SAVE', 'user_save');
define('KMS_OCI_QUEUE_ACTION_USER_DELETE', 'user_delete');
define('KMS_OCI_QUEUE_ACTION_PERMS_ATTACH', 'permissions_attach');
define('KMS_OCI_QUEUE_ACTION_BUNDLE_SAVE', 'bundle_save');
// Atodo: Create actual job for this!!
define('KMS_OCI_QUEUE_ACTION_BUNDLE_DELETE', 'bundle_delete');
define('KMS_OCI_QUEUE_ACTION_CLONE_USER_PERMS', 'clone_user_perms');
define('KMS_OCI_QUEUE_ACTION_REMOVE_ALL_BUNDLES', 'remove_all_bundles');
define('KMS_OCI_QUEUE_ACTION_BUNDLES_ATTACH', 'attach_bundles_users');
define('KMS_OCI_QUEUE_ACTION_BOUNDING_BOX_UPDATE', 'bounding_box_update');
define('KMS_OCI_QUEUE_CRON_DELETE_JOBS_KEEP', 25);
define('KMS_OCI_QUEUE_CRON_DELETE_JOBS_PER_RUN', 100);

require_once 'kms_oci_queue.actions.inc';

/**
 * Implements hook_menu().
 */
function kms_oci_queue_menu() {
  $items = array();
  $items['admin/reports/kms-oci-queue'] = array(
    'title' => 'Oci queue status',
    'description' => 'Show oci queue status',
    'page callback' => 'kms_oci_queue_admin_page',
    'access arguments' => array('administer kms oci queue'),
    'type' => MENU_NORMAL_ITEM,
  );
  $items['kms-oci-queue/ajax/load-log/%'] = array(
    'title' => 'Show job log',
    'page callback' => 'kms_oci_queue_admin_page_ajax_job_log',
    'access arguments' => array('administer kms oci queue'),
    'page arguments' => array(3),
    'type' => MENU_CALLBACK,
  );
  $items['kms-oci-queue/ajax/poll-jobs'] = array(
    'title' => 'Show job log',
    'page callback' => 'kms_oci_queue_admin_page_ajax_jobs',
    'access arguments' => array('administer kms oci queue'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_permission().
 */
function kms_oci_queue_permission() {
  return array(
    'administer kms oci queue' => array(
      'title' => t('Administer Kms Oci Queue.'),
    ),
  );
}

/**
 * Implements hook_ctools_plugin_type().
 */
function kms_oci_queue_ctools_plugin_type() {
  return array(
    'queue_runner' => array(
      'use hooks' => FALSE,
    ),
  );
}

/**
* Implements hook_ctools_plugin_directory().
 */
function kms_oci_queue_ctools_plugin_directory($module, $plugin) {
  $path = '';
  switch ($module) {
    case 'kms_system_status':
      $path = 'plugins/system_status';
      break;
  }

  return $path;
}

/**
 * Implements hook_cronapi().
 */
function kms_oci_queue_cronapi($op, $job = NULL) {
  switch ($op) {
    case 'list':
      return array(
        'kms_oci_queue_query_creator_run' => 'Run query creator',
        'kms_oci_queue_cleanup_jobs' => 'Cleanup job queue',
        'kms_oci_queue_consistency_check_services_diff' => 'Check service data consistency between dbs',
      );

    case 'rule':
      switch ($job) {
        case 'kms_oci_queue_query_creator_run':
          return '*/1 * * * *';

        case 'kms_oci_queue_cleanup_jobs':
          return '4 */2 * * *';

        case 'kms_oci_queue_consistency_check_services_diff':
          return '6 */4 * * *';
      }
      break;

    case 'execute':
      switch ($job) {
        case 'kms_oci_queue_query_creator_run':
          kms_oci_queue_query_creator_run();
          break;

        case 'kms_oci_queue_cleanup_jobs':
          kms_oci_queue_cron_cleanup_jobs();
          break;

        case 'kms_oci_queue_consistency_check_services_diff':
          kms_oci_queue_consistency_check_services_diff();
          break;
      }
      break;
  }

}

/**
 * Implements hook_cron_queue_info().
 */
function kms_oci_queue_cron_queue_info() {
  $queues['kms_oci_queue_query'] = array(
    'worker callback' => 'kms_oci_queue_query_run',
    'time' => 120,
  );
  return $queues;
}

/**
 * Process a job queue item of the query creator queue.
 */
function kms_oci_queue_query_creator_run() {
  // Load query creator queue.
  $creator_queue = DrupalQueue::get(
    KmsOciQueueJob::$queues['creator']['name'],
    TRUE
  );
  // Load query executor queue.
  $exe_queue = DrupalQueue::get(
    KmsOciQueueJob::$queues['executor']['name'],
    TRUE
  );

  $last_gid = NULL;

  do {
    // We set the expire time to a high number (30 days)
    // because the task is not idempotent.
    $item = $creator_queue->claimItem(60 * 60 * 24 * 30);
    // If no queue item found do nothing.
    if (!$item) {
      break;
    }
    // Find job id.
    $jid = $item->item_id;
    $job = KmsOciQueueJobFactory::get($jid);

    if ($job->gid && $job->gid !== $last_gid && !is_null($last_gid)) {
      $creator_queue->releaseItem($item);
      $last_gid = NULL;
    }
    elseif ($job->gid && ($job->gid === $last_gid || is_null($last_gid))) {
      kms_oci_queue_query_creator_process_job($job, $item, $exe_queue);
      $last_gid = $job->gid;
    }
    elseif (!$job->gid) {
      kms_oci_queue_query_creator_process_job($job, $item, $exe_queue);
      $last_gid = NULL;

    }
    else {
      $last_gid = NULL;
    }

  } while ($job && $job->gid === $last_gid);
}

function kms_oci_queue_query_creator_process_job($job, $item, $exe_queue) {
  $jid = $job->jid;
  $job->changeStatus(
    KmsOciQueueJob::STATUS_PROCESSING,
    'Writing sql lines...'
  );

  // Creator item with data to create query queue.
  $creator_item = $item->data;
  // We need parameters in order to create queries.
  if (empty($creator_item->params)) {
    return;
  }
  // Do not need original item anymore.
  unset($item);

  // Create executor queue items via ctools plugins.
  ctools_include('plugins');
  $plugins = ctools_get_plugins('kms_oci_queue', 'queue_runner');

  array_walk(
    $plugins,
    function($plugin) use ($jid, $creator_item, $exe_queue) {
      // Only load plugins corresponding to the queue item action.
      if ($plugin['action'] != $creator_item->action) {
        return;
      }
      // Because Drupal auto loading is flaky we have to do it ourselves, sigh.
      module_load_include('inc', 'kms_permissions', 'includes/kms_perms_diff');
      // Get proper plugin function in order to create executor items.
      if ($function = ctools_plugin_get_function($plugin, 'query_creator_run')) {
        $function($jid, $creator_item, $exe_queue);
      }
    }
  );

}

/**
 * Process a job queue item of the query queue.
 *
 * @param object $item
 *   Queue item object.
 */
function kms_oci_queue_query_run($item) {
  // Load query queue executor plugins to create sql output.
  ctools_include('plugins');
  $plugins = ctools_get_plugins('kms_oci_queue', 'queue_runner');
  $output = '';
  array_walk($plugins, function($plugin) use ($item, &$output) {
    // Because Drupal auto loading is flaky we have to do it ourselves, sigh.
    module_load_include('inc', 'kms_permissions', 'includes/kms_perms_diff');
    // Only load plugins corresponding to the queue item action.

    if ($plugin['action'] != $item->action) {
      return;
    }
    // Accumulate output.
    if ($function = ctools_plugin_get_function($plugin, 'query_run')) {
      $output .= $function($item);
    }
  });
  $job = KmsOciQueueJobFactory::get($item->jid);
  // Construct filenames / paths.
  $tmp_filename = sprintf('temporary://%s.tmp', $job->jid);
  // Write job (sql) file.
  $filename = $job->jid . '.job';
  $dest_name = implode(
    '/',
    array(
      KMS_OCI_QUEUE_ENGINE_ROOT_URI,
      KMS_OCI_QUEUE_ENGINE_DIR_JOBS,
      $filename,
    )
  );

  // If no output and nothing has already been written do nothing
  // and delete job.
  if (empty($output) && $item->is_last_item && !file_exists($tmp_filename)) {
    $job->changeStatus(
      KmsOciQueueJob::STATUS_DONE,
      'No lines to process in this job'
    );
    // Delete job if no sql lines are present.
    $job->delete();
    return;
  }
  // If no output and we are not at the last item skip item.
  elseif (empty($output) && !$item->is_last_item) {
    return;
  }

  // Append output to tmp file.
  if (file_put_contents($tmp_filename, $output, FILE_APPEND) === FALSE) {
    $job->changeStatus(
      KmsOciQueueJob::STATUS_FAILED,
      'File creation failed. Could not write to tmp dir.'
    );
  }
  // If last line has been written move tmp file to actual destination dir.
  elseif ($item->is_last_item) {
    $move = file_unmanaged_move($tmp_filename, $dest_name, FILE_EXISTS_REPLACE);
    if ($move) {
      $job->changeStatus(
        KmsOciQueueJob::STATUS_FILE_READY,
        'File creation succeeded. Saved in %filepath',
        array('%filepath' => $move)
      );
      $job->finishQueue();
    }
    else {
      $job->changeStatus(
        KmsOciQueueJob::STATUS_FAILED,
        'File creation failed. Cannot move filename from tmp dir.'
      );
    }

  }

}

/**
 * Get all current job ids.
 *
 * @param array $job_statuses
 *   Possbility for including/excluding jobs with certain statuses.
 *
 * @return array
 *   Array of all current job ids.
 */
function kms_oci_queue_get_job_ids($job_statuses = array()) {
  $job_statuses += array(
    'include' => array(),
    'exclude' => array(),
  );
  $query = db_select('kms_oci_queue_job', 'j')->fields('j', array('jid'));
  if (!empty($job_statuses['include'])) {
    $query->condition('j.status', $job_statuses['include'], 'IN');
  }
  if (!empty($job_statuses['exclude'])) {
    $query->condition('j.status', $job_statuses['exclude'], 'NOT IN');
  }
  $result = $query->orderBy('jid')->execute()->fetchCol();
  return $result ?: array();
}

/**
 * Show Kms oci report page.
 *
 * @return array
 *   Render array.
 */
function kms_oci_queue_admin_page() {
  $options = array('query' => array('destination' => 'admin/reports/kms-oci-queue'));
  $prefix[] = l(
    'Create queue from waiting jobs',
    'admin/ultimate-cron/service/start/kms_oci_queue_query_creator_run',
    $options
  );
  $prefix[] = l(
    'Process queue items marked as processing',
    'admin/ultimate-cron/service/start/ultimate_cron_queue_kms_oci_queue_query',
    $options
  );
  $output['#prefix'] = implode(' - ', $prefix);
  $output['queues'] = kms_oci_queue_admin_page_jobs('jobs_waiting');
  $output['queues'] += kms_oci_queue_admin_page_jobs('jobs_done');

  $module_path = drupal_get_path('module', 'kms_oci_queue');
  $output['#attached']['js'][] = $module_path . '/js/kms_oci_queue_reports.js';
  $output['#attached']['css'][] = $module_path . '/css/kms_oci_queue_reports.css';
  $output['#attached']['library'][] = array('beautytips', 'beautytips-module');
  $output['#attached']['library'][] = array('beautytips', 'excanvas_r3');
  if (variable_get('beautytips_ltr', FALSE)) {
    $output['#attached']['library'][] = array('beautytips', 'beautytips-ltr');
  }

  return $output;
}

/**
 * Render table with kms oci jobs.
 *
 * @param string $type
 *   jobs_waiting / jobs_done.
 *
 * @return array
 *   Drupal render array.
 */
function kms_oci_queue_admin_page_jobs($type) {
  switch ($type) {
    case 'jobs_waiting':
      $jids = kms_oci_queue_get_job_ids(
        array('exclude' => array(KmsOciQueueJob::STATUS_DONE))
      );
      $title = t('Jobs');
      break;
    case 'jobs_done':
      $jids = kms_oci_queue_get_job_ids(
        array('include' => array(KmsOciQueueJob::STATUS_DONE))
      );
      rsort($jids);
      $title = t('Jobs done');
      break;
  }
  $output = array(
    '#type' => 'container',
    '#attributes' => array(
      'class' => array('kms-oci-queue-jobs-overview'),
    ),
  );

  $jobs_output = array(
    '#type' => 'container',
    '#attributes' => array(
      'class' => array('kms-oci-queue-jobs'),
    ),
  );
  $jobs_output["job_queue_title"] = array(
    '#type' => 'html_tag',
    '#tag' => 'h2',
    '#value' => $title,
  );
  $rows = array();
  foreach ($jids as $jid) {
    $job = KmsOciQueueJobFactory::get($jid);
    $conn = KmsOciQueueJobDb::getConnectionSettings($job->cid);
    $job_action = sprintf(
      '<strong>%s</strong> | %s [<a href="#" title="%s" class="more">%s</a>]',
      $job->action,
      $conn['user'],
      htmlentities($job->actionDetails),
      t('info')
    );
    $rows[] = array(
      'data' => array(
        array(
          'data' => $job->jid,
          'data-jid' => $job->jid,
          'class' => 'job-log-trigger',
        ),
        array(
          'data' => $job_action,
          'data-jid' => $job->jid,
          'class' => array('job-info'),
        ),
        array(
          'data' => $job->status->message,
          'data-jid' => $job->jid,
          'class' => array(
            'status',
            KmsOciQueueJob::cssClassStatus($job->status->status),
          ),
        ),
        array('data' => format_date($job->created)),
      ),
      'class' => array(
        KmsOciQueueJobGroup::cssClassJobGroup($job, $type),
      )
    );

    $rows[] = array(
      'class' => array('kms-oci-queue-job-log'),
      'data-jid' => $job->jid,
      'data' => array(
        array('data' => '&nbsp;', 'colspan' => 4),
      ),
    );
  }

  if (empty($rows)) {
    $rows[] = array(
      'data' => array(
        array('data' => t('There are currently no jobs.'), 'colspan' => 4),
      ),
    );
  }

  $jobs_output["job_queue"] = array(
    '#theme' => 'table',
    '#header' => array(t('Job id'), t('Info'), t('Status'), t('Created')),
    '#rows' => $rows,
  );

  $table_id = "kms_oci_queue_jobs_" . uniqid();
  $output[$table_id] = $jobs_output;
  return $output;
}

/**
 * Print a log for a given job.
 * 
 * @param int $jid
 *   Job id
 */
function kms_oci_queue_admin_page_ajax_job_log($jid) {
  if (empty($jid)) {
    return;
  }
  $json['html'] = '';
  $job = KmsOciQueueJobFactory::get($jid);
  if (!empty($job)) {
    $log = $job->getLog();
  }
  $output = array();
  if (!empty($log)) {
    foreach ($log as $lid => $entry) {
      $message_vars = unserialize($entry->variables);
      if (empty($message_vars) || !is_array($message_vars)) {
        $message_vars = array();
      }
      $classes = array(KmsOciQueueJob::cssClassSeverity($entry->severity));
      $rows[] = array(
        array(
          'data' => format_date($entry->timestamp),
          'colspan' => 1,
          'class' => $classes,
        ),
        array(
          'data' => format_string($entry->message, $message_vars),
          'colspan' => 2,
          'class' => $classes,
        ),
      );
    }
    $output["log_$lid"] = array(
      '#theme' => 'table',
      '#header' => array(),
      '#rows' => $rows,
    );
    $json['html'] = render($output);
  }

  drupal_json_output($json);
  exit;
}

/**
 * Loads job tables if jobs have changed and put html in json object.
 */
function kms_oci_queue_admin_page_ajax_jobs() {
  $html = '';
  $state_changed = _kms_oci_queue_jobs_state_changed();
  if ($state_changed) {
    $output['queues'] = kms_oci_queue_admin_page_jobs('jobs_waiting');
    $output['queues'] += kms_oci_queue_admin_page_jobs('jobs_done');
    $html = render($output);
  }

  drupal_json_output(array(
    'stateChanged' => $state_changed,
    'html' => $html,
  ));
  exit;
}

/**
 * Generate sql line for a kms_oci_queue job.
 *
 * @param string $type
 *   What type of query. Eg. 'insert'.
 * @param array $data
 *   Query data (':col' => data).
 * @param string $table
 *   Which table is manipulated.
 *
 * @return string
 *   Query.
 */
function _kms_oci_queue_sql_generate_line($type, $data, $table) {
  switch ($type) {
    case 'insert':
      $query = kms_oci_generate_query('insert', $data, array('table' => $table));
      break;
  }

  $patterns = $replacements = array();
  array_walk($data, function($v, $k) use(&$patterns, &$replacements){
    $patterns[] = '#\\' . $k . '#';
    $replacements[] = "'$v'";
  });
  return preg_replace($patterns, $replacements, $query, 1) . ";\n";

}

/**
 * Process a save bundle queue item created by a query creator queue.
 *
 * The function creates sql lines to be written in a kms_oci_queue job file.
 *
 * @param object $item
 *   Queue item.
 *
 * @return string
 *   Sql output.
 */
function _kms_oci_queue_process_perms_query_creator_queue_item($item) {
  $output = array();
  foreach ($item->diff as $perm_type => $diff) {
    $data = array(
      'userid' => $item->kms_id,
    );
    switch ($perm_type) {
      case 'services':
        $data['featureinfo'] = 0;
        foreach ($diff['add'] as $sid => $service_values) {
          if (!empty($service_values)) {
            $data['serviceid'] = $sid;
            $data += $service_values;
            $sql = new KmsOciQueueSql('services', $data);
            $output[] = $sql->generate('upsert');
          }
        }
        foreach ($diff['remove'] as $sid) {
          $data['serviceid'] = $sid;
          $sql = new KmsOciQueueSql('services', $data);
          $output[] = $sql->generate('delete');
        }
        break;

      case 'applications':
        foreach ($diff['add'] as $gid) {
          $data['groupid'] = $gid;
          $sql = new KmsOciQueueSql('applications', $data);
          $output[] = $sql->generate('upsert');
        }
        foreach ($diff['remove'] as $gid) {
          $data['groupid'] = $gid;
          $sql = new KmsOciQueueSql('applications', $data);
          $output[] = $sql->generate('delete');
        }
        break;
    }
  }

  if (!empty($output)) {
    array_unshift($output, $sql->generateWrapper('header'));
    $output[] = $sql->generateWrapper('footer');
  }

  // Return all created query lines.
  return implode("\n", $output);
}

/**
 * Pretty-print JSON string.
 *
 * Use 'format' option to select output format
 * currently html and txt supported, txt is default.
 * Use 'indent' option to override the indentation string set in the format
 * by default for the 'txt' format it's a tab
 *
 * @param string $json
 *   Original JSON string
 * @param array $options
 *   Encoding options
 *
 * @return string
 *   Prettified json.
 */
function kms_oci_queue_json_pretty($json, $options = array()) {
  $tokens = preg_split('|([\{\}\]\[,])|', $json, -1, PREG_SPLIT_DELIM_CAPTURE);
  $result = '';
  $indent = 0;

  $format = 'txt';

  $ind = "    ";

  if (isset($options['format'])) {
    $format = $options['format'];
  }

  switch ($format) {
    case 'html':
      $line_break = '<br />';
      $ind = '&nbsp;&nbsp;&nbsp;&nbsp;';
      break;

    default:
    case 'txt':
      $line_break = "\n";
      $ind = "    ";
      break;
  }

  // Override the defined indent setting with the supplied option.
  if (isset($options['indent'])) {
    $ind = $options['indent'];
  }

  $in_literal = FALSE;
  foreach ($tokens as $token) {
    if ($token == '') {
      continue;
    }

    $prefix = str_repeat($ind, $indent);
    if (!$in_literal && ($token == '{' || $token == '[')) {
      $indent++;
      if (($result != '') && ($result[(strlen($result) - 1)] == $line_break)) {
        $result .= $prefix;
      }
      $result .= $token . $line_break;
    }
    elseif (!$in_literal && ($token == '}' || $token == ']')) {
      $indent--;
      $prefix = str_repeat($ind, $indent);
      $result .= $line_break . $prefix . $token;
    }
    elseif (!$in_literal && $token == ',') {
      $result .= $token . $line_break;
    }
    else {
      $result .= ($in_literal ? '' : $prefix) . $token;

      // Count # of unescaped double-quotes in token, subtract # of
      // escaped double-quotes and if the result is odd then we are
      // inside a string literal.
      if ((substr_count($token, "\"") - substr_count($token, "\\\"")) % 2 != 0) {
        $in_literal = !$in_literal;
      }
    }
  }
  return $result;
}

/**
 * Prepares update user data for oracle insertion.
 *
 * @param object $account
 *   Drupal user account.
 * @param mixed $user
 *   Drupal user object or FALSE.
 *
 * @return array $data
 *   Oracle user data.
 */
function _kms_oci_queue_create_update_smuser_data($account, $user = FALSE) {
  $data = _kms_user_oracle_default_user_data($account);
  unset($data['user_extra']['usertype']);
  unset($data['user_extra']['usertype_info']);

  $data['user']['disabled'] = (integer)!$account->status;
  if (isset($account->field_address[LANGUAGE_NONE][0]['first_name'])) {
    $data['user']['firstname']
      = $account->field_address[LANGUAGE_NONE][0]['first_name'];
  }
  if (isset($account->field_address[LANGUAGE_NONE][0]['last_name'])) {
    $data['user']['lastname']
      = $account->field_address[LANGUAGE_NONE][0]['last_name'];
  }
  if (isset($account->field_phone[LANGUAGE_NONE][0]['value'])) {
    $data['user']['telephonenumber']
      = $account->field_phone[LANGUAGE_NONE][0]['value'];
  }
  if (isset($account->field_debtor_nr[LANGUAGE_NONE][0]['value'])) {
    $data['user']['debitorno']
      = $account->field_debtor_nr[LANGUAGE_NONE][0]['value'];
  }
  // smuser_extra.
  if (isset($account->field_user_type[LANGUAGE_NONE][0]['tid'])) {
    $data['user_extra']['usertype']
      = $account->field_user_type[LANGUAGE_NONE][0]['tid'];
  }
  if (isset($account->field_user_type_info[LANGUAGE_NONE][0]['value'])) {
    $data['user_extra']['usertype_info']
      = $account->field_user_type_info[LANGUAGE_NONE][0]['value'];
  }
  else {
    $data['user_extra']['usertype_info'] = '';
  }
  if (isset($account->field_newsletter[LANGUAGE_NONE][0]['value'])) {
    $data['user_extra']['receive_newsletter']
      = $account->field_newsletter[LANGUAGE_NONE][0]['value'];
  }
  if (isset($account->field_terms_and_conditions[LANGUAGE_NONE][0]['value'])) {
    $data['user_extra']['accept_terms']
      = $account->field_terms_and_conditions[LANGUAGE_NONE][0]['value'];
  }
  if (isset($account->field_contact_me[LANGUAGE_NONE][0]['value'])) {
    $data['user_extra']['contact_me']
      = $account->field_contact_me[LANGUAGE_NONE][0]['value'];
  }

  return $data;
}

/**
 * Formats oracle data for insertion.
 *
 * @param object $account
 *   Drupal user account.
 *
 * @return array
 */
function _kms_oci_queue_create_insert_smuser_data($account) {
  $data = _kms_user_oracle_default_user_data($account);

  if (isset($account->field_user_type[LANGUAGE_NONE][0]['tid'])) {
    $data['user_extra']['usertype']
      = $account->field_user_type[LANGUAGE_NONE][0]['tid'];
  }
  if (isset($account->field_user_type_info[LANGUAGE_NONE][0]['value'])) {
    $data['user_extra']['usertype_info']
      = $account->field_user_type_info[LANGUAGE_NONE][0]['value'];
  }
  if (isset($account->field_newsletter[LANGUAGE_NONE][0]['value'])) {
    $data['user_extra']['receive_newsletter']
      = $account->field_newsletter[LANGUAGE_NONE][0]['value'];
  }
  if (isset($account->field_terms_and_conditions[LANGUAGE_NONE][0]['value'])) {
    $data['user_extra']['accept_terms']
      = $account->field_terms_and_conditions[LANGUAGE_NONE][0]['value'];
  }
  if (isset($account->field_contact_me[LANGUAGE_NONE][0]['value'])) {
    $data['user_extra']['contact_me']
      = $account->field_contact_me[LANGUAGE_NONE][0]['value'];
  }

  return $data;
}


/**
 * Cleanup old jobs cron job.
 */
function kms_oci_queue_cron_cleanup_jobs() {
  // The statuses of the jobs we want to delete.
  $statuses = array('include' => array(KmsOciQueueJob::STATUS_DONE));
  // Get all job ids with the status: 'done'.
  $jids = kms_oci_queue_get_job_ids($statuses);
  rsort($jids);
  // Keep some jobs in overview.
  $jids = array_slice($jids, KMS_OCI_QUEUE_CRON_DELETE_JOBS_KEEP);
  // Delete the rest limited to number of jobs per run.
  $no_jobs_per_run = KMS_OCI_QUEUE_CRON_DELETE_JOBS_PER_RUN;
  if (count($jids) > $no_jobs_per_run) {
    $jids = array_slice($jids, -1 * $no_jobs_per_run, $no_jobs_per_run);
  }
  // Delete jobs and log it.
  foreach($jids as $jid) {
    $job = KmsOciQueueJobFactory::get($jid);
    if (is_object($job)) {
      $job->delete();
      $job_file = sprintf(
        "%s/%s/%s.job",
        KMS_OCI_QUEUE_ENGINE_ROOT_URI,
        KMS_OCI_QUEUE_ENGINE_DIR_JOBS_PROCESSED,
        $jid
      );
      if (file_exists($job_file)) {
        unlink($job_file);
      }
      watchdog(
        implode(':', array(KMS_OCI_QUEUE_PREFIX, $jid)),
        'kms_oci_queue_cron_cleanup_jobs deleted job: @jid',
        array('@jid' => $jid)
      );
    }
  }

}

/**
 * If kms oci table and logs state has changed.
 *
 * @return bool
 *   Has state changed?
 */
function _kms_oci_queue_jobs_state_changed() {
  $query = db_select('kms_oci_queue_job', 'j')
    ->fields('j', array('jid', 'status'))
    ->orderBy('jid');
  $jobs = $query->execute()->fetchAllKeyed(0, 1);
  $query = db_select('kms_oci_queue_log', 'l')
    ->fields('l', array('lid', 'jid'))
    ->orderBy('lid');
  $log = $query->execute()->fetchAllKeyed(0, 1);
  // Create state hash.
  $jobs_state = md5(serialize(array($jobs, $log)));
  // If current state is not the same as the last one set variable
  // to remember state and return TRUE.
  if ($jobs_state != variable_get('kms_oci_queue_jobs_state', '')) {
    variable_set('kms_oci_queue_jobs_state', $jobs_state);
    return TRUE;
  }
  // Otherwise false.
  else {
    return FALSE;
  }

}

/**
 * Implements hook_user_presave().
 */
function kms_oci_queue_user_presave(&$edit, $account, $category) {
  $account_new = (object)$edit;
  $account_new->uid = $account->uid;
  $data = _kms_user_user_update_oci_queue_prepare_data($account_new, $account);
  $data_hash = md5(json_encode($data['user_data']));
  // We save the hash in the user object so we can detect user data changes.
  $edit['data']['kms_oci_queue_user_data_hash'] = $data_hash;
}

/**
 * Check if a job is accessible.
 *
 * @param string $action
 *
 * @return bool
 *   Access to job?
 */
function kms_oci_queue_job_is_accessible($action) {
  $access_values = module_invoke_all('kms_oci_queue_job_access', $action);
  $restrictions = array_filter($access_values, function($v) { return !$v; });
  return empty($restrictions);
}

/**
 * Cron consistency check function wrapper.
 *
 * Ultimate cron settings seems flaky concerning arguments etc.
 */
function kms_oci_queue_consistency_check_services_diff() {
  kms_oci_queue_consistency_check('services', 'diff');
  kms_oci_queue_consistency_generate_resolving_sql('services', 'oracle');
}



/**
 * Executes a data consistency check between postgres and oracle.
 *
 * Supports different "data types" and methods (diff etc.).
 *
 * @param string $data_type
 * @param string $method
 * @throws Exception
 */
function kms_oci_queue_consistency_check($data_type, $method) {
  module_load_include('inc', 'kms_oci_queue', 'includes/kms_oci_queue.consistency');
  $run_mode = function_exists('drush_main') ? 'drush' : 'normal';
  $drush_option_mode = function_exists('drush_main') ? drush_get_option('mode') : FALSE;
  $class_name_prefix = 'cData' . ucfirst($data_type);
  $class_name_postgres = $class_name_prefix . 'Postgres';
  $class_name_oracle = $class_name_prefix . 'Oracle';

  // Check if classes are defined.
  if (
    !class_exists($class_name_postgres)
    && !class_exists($class_name_oracle)
  ) {
    return;
  }

  if ($run_mode == 'normal') {
    watchdog(
      sprintf('%s:%s', KMS_OCI_QUEUE_PREFIX, __FUNCTION__),
      'kms_oci_queue_consistency_check initiated.'
    );
  }

  $dir = cHelper::dirConsistencyDiff;
  if ($run_mode == 'drush') {
    $dir .= '_drush';
  }
  $mkdir = FALSE;
  $del_files = file_unmanaged_delete_recursive($dir);
  if ($del_files) {
    $mkdir = file_prepare_directory($dir, FILE_CREATE_DIRECTORY);
  }
  if (!$del_files || !$mkdir) {
    return;
  }

  $i = $user_count = 0;
  $chunks = cHelper::getUidChunks();

  if ($run_mode == 'drush') {
    drush_print(
      dt('Working on: !dir_name.', array('!dir_name' => $dir))
    );
    drush_print(
      dt('Chunk count: !chunk_count.', array('!chunk_count' => count($chunks)))
    );
    drush_print(
      dt('Chunk size: !chunk_size.', array('!chunk_size' => cHelper::uidChunkSize))
    );
  }

  foreach ($chunks as $uids) {
    $postgres = new $class_name_postgres($uids);
    $oracle = new $class_name_oracle($uids);
    $data_check = new cDataCheck($postgres, $oracle);
    if (method_exists($data_check, $method)) {
      if ($method == 'diff' && $drush_option_mode) {
        $mode_map = array(
          'postgres' => 'a',
          'oracle' => 'b',
        );
        if (empty($mode_map[$drush_option_mode])) {
          throw new Exception('Mode type does not exist.');
        }
        else {
          $result = $data_check->diff($mode_map[$drush_option_mode]);
        }
      }
      else {
        $result = $data_check->diff();
      }
      // If any diff's exist then create xml.
      if (!empty($result)) {
        $xml = new SimpleXMLElement('<?xml version="1.0" encoding="utf-8"?><user_diffs></user_diffs>');
        foreach ($result as $uid => $diffs) {
          $user = $xml->addChild('user');
          $user->addChild('id', $uid);
          foreach ($diffs as $diff_key => $ids) {
            $diff_key = str_replace(':', '-', $diff_key);
            $diff_ids = $user->addChild($diff_key);
            foreach ($ids as $id) {
              $diff_ids->addChild('id', $id);
            }
          }
        }
        // If xml object is populated then write file.
        if (is_object($xml)) {
          $file = fopen(sprintf('%s/diff%s.xml', $dir, $i ? "_$i" : ''), "w");
          fwrite($file, $xml->asXML());
          fclose($file);
          $i++;
        }

      }

      $user_count += count($uids);
      if ($run_mode == 'drush') {
        drush_print(
          format_plural($user_count, '1 user', '@count users') . dt(' processed.')
        );
      }

    }
  }

  if ($run_mode == 'drush') {
    drush_print(dt('Done.'));
  }
  else {
    watchdog(
      sprintf('%s:%s', KMS_OCI_QUEUE_PREFIX, __FUNCTION__),
      format_plural($user_count, '1 user', '@count users') . ' processed.'
    );
  }

}

/**
 * Generates sql file that cleans up target database.
 *
 * @param string $data_type
 * @param string $target_db
 */
function kms_oci_queue_consistency_generate_resolving_sql($data_type, $target_db) {
  module_load_include('inc', 'kms_oci_queue', 'includes/kms_oci_queue.consistency');
  $run_mode = function_exists('drush_main') ? 'drush' : 'normal';

  $wms_ids = kms_permissions_get_service_ids_by_type('wms');

  if ($run_mode == 'normal') {
    watchdog(
      sprintf('%s:%s', KMS_OCI_QUEUE_PREFIX, __FUNCTION__),
      'kms_oci_queue_consistency_generate_resolving_sql initiated.'
    );
  }

  $dir = cHelper::dirConsistencyDiff;
  if ($run_mode == 'drush') {
    $dir .= '_drush';
  }
  $sql_file = sprintf('%s/consistency_resolve_%s.sql', $dir, $target_db);
  if (file_exists($sql_file)) {
    unlink($sql_file);
  }

  switch ($target_db) {
    case 'oracle':
      switch ($data_type) {
        case 'services':
          $files = file_scan_directory($dir, '/.*\.xml$/');
          if (empty($files) && $run_mode == 'drush') {
            drush_print(dt('No diff files found.'));
            return;
          }
          ksort($files);
          $i = 0;
          foreach ($files as $file) {
            if ($run_mode == 'drush') {
              drush_print(
                dt('Processing file: !filename.', array('!filename' => $file->filename))
              );
            }
            $xml = simplexml_load_file($file->uri);
            foreach ($xml->user as $user) {
              $userid = (string) $user->id;
              $output = array();
              $sids_postgres = array_unique((array) $user->{'diff-Services-Postgres'});
              $sids_postgres = !empty($sids_postgres['id']) ? $sids_postgres['id'] : array();

              if (!is_array($sids_postgres)) {
                $sids_postgres = array($sids_postgres);
              }
              foreach ($sids_postgres as $sid) {
                $service_data = array(
                  'userid' => $userid,
                  'serviceid' => $sid,
                  'featureinfo' => 0,
                );

                $service_data += kms_permissions_get_service_bounding_box($sid);
                // If a service is a wms service then set feature info to 1.
                if (in_array($sid, $wms_ids)) {
                  $service_data['featureinfo'] = 1;
                }
                $sql = new KmsOciQueueSql('services', $service_data);
                $output[] = $sql->generate('insert');
              }

              $sids_oracle = array_unique((array) $user->{'diff-Services-Oracle'});
              $sids_oracle = !empty($sids_oracle['id']) ? $sids_oracle['id'] : array();
              if (!is_array($sids_oracle)) {
                $sids_oracle = array($sids_oracle);
              }
              foreach ($sids_oracle as $sid) {
                $service_data = array(
                  'userid' => $userid,
                  'serviceid' => $sid,
                );
                $sql = new KmsOciQueueSql('services', $service_data);
                $output[] = $sql->generate('delete');
              }

              if (!empty($output)) {
                array_unshift($output, $sql->generateWrapper('header'));
                $output[] = $sql->generateWrapper('footer');
                file_put_contents($sql_file, implode("\n", $output), FILE_APPEND);
              }
              $i++;
              if ($run_mode == 'drush') {
                drush_print(format_plural($i, '1 user', '@count users') . dt(' processed.'));
              }
            }
          }
          break;
      }
      break;

    case 'postgres':
      switch ($data_type) {
        case 'services':
          $files = file_scan_directory($dir, '/.*\.xml$/');
          if (empty($files) && $run_mode == 'drush') {
            drush_print(dt('No diff files found.'));
            return;
          }
          ksort($files);
          $i = 0;
          foreach ($files as $file) {
            if ($run_mode == 'drush') {
              drush_print(
                dt('Processing file: !filename.', array('!filename' => $file->filename))
              );
            }
            $xml = simplexml_load_file($file->uri);
            foreach ($xml->user as $user) {
              $userid = (string) $user->id;
              $user_oracle = KmsPermsOracleInfo::userLoad($userid);
              // If, for some reason, we cannot load a user in oracle
              // we use the user id we know.
              $user_oracle_uid = !empty($user_oracle->uid) ? $user_oracle->uid : $userid;
              $output = array();
              $sids_oracle = array_unique((array) $user->{'diff-Services-Oracle'});
              $sids_oracle = !empty($sids_oracle['id']) ? $sids_oracle['id'] : array();

              if (!is_array($sids_oracle)) {
                $sids_oracle = array($sids_oracle);
              }

              $service_type_deltas = array();
              foreach ($sids_oracle as $sid) {
                $service_type = KmsPermsOracleInfo::serviceGetTypeFromId($sid);
                if (empty($service_type)) {
                  continue;
                }
                $tables = array(
                  sprintf("field_data_field_bundle_webservices_%s", $service_type),
                  sprintf("field_revision_field_bundle_webservices_%s", $service_type),
                );
                $field = sprintf("field_bundle_webservices_%s_value", $service_type);
                $delta = kms_permissions_get_next_delta_webservices($user_oracle_uid, $service_type);
                // We need to increment delta
                // if we have more services of the same type for one user.
                if (in_array($service_type, array_keys($service_type_deltas))) {
                  $delta = ++$service_type_deltas[$service_type];
                }
                else {
                  $service_type_deltas[$service_type] = $delta;
                }

                foreach ($tables as $table) {
                  $output[] = <<<EOD

INSERT INTO $table (entity_type, bundle, deleted, entity_id, revision_id, language, delta, $field)
VALUES ('user', 'user', 0, $user_oracle_uid, $user_oracle_uid, 'und', $delta, '$sid');

EOD;
                }
              }
                 // Todo: fix deletion later. Not needed for now.
//              $sids_postgres = array_unique((array) $user->{'diff-Services-Postgres'});
//              $sids_postgres = !empty($sids_postgres['id']) ? $sids_postgres['id'] : array();
//              if (!is_array($sids_postgres)) {
//                $sids_postgres = array($sids_postgres);
//              }
//              foreach ($sids_postgres as $sid) {
//                $service_type = KmsPermsOracleInfo::serviceGetTypeFromId($sid);
//                if (empty($service_type)) {
//                  continue;
//                }
//                $tables = array(
//                  sprintf("field_data_field_bundle_webservices_%s", $service_type),
//                  sprintf("field_revision_field_bundle_webservices_%s", $service_type),
//                );
//                $field = sprintf("field_bundle_webservices_%s_value", $service_type);
//
//                foreach ($tables as $table) {
//                  $output[] = <<<EOD
//                    DELETE FROM $table WHERE entity_type = 'user' AND entity_id = $user_oracle_uid AND $field = '$sid'
//EOD;
//                }
//
//              }

              if (!empty($output)) {
                file_put_contents($sql_file, implode("\n", $output), FILE_APPEND);
              }
              $i++;
              if ($run_mode == 'drush') {
                drush_print(format_plural($i, '1 user', '@count users') . dt(' processed.'));
              }
            }
          }
          break;
      }
      break;
  }

  if ($run_mode == 'drush') {
    drush_print(dt('Done.'));
  }
  else {
    watchdog(
      sprintf('%s:%s', KMS_OCI_QUEUE_PREFIX, __FUNCTION__),
      format_plural($i, '1 user', '@count users') . ' processed.'
    );
  }
}

/**
 * Validates if the user is already in the kms oci queue.
 *
 * @param array $form
 *   Drupal form array.
 * @param array $form_state
 *   Drupal form state array.
 */
function _kms_oci_queue_validate_job_blocker_user($form, &$form_state) {
  $user = $form['#user'];
  if (KmsOciQueueJobBlocker::userIsBlocked($user->uid)) {
    form_set_error('submit', t('A job with same user is in the queue. Please wait until it has been executed.'));
    // GST wants form to be reset and reflect what is stored in drupal.
    // So we redirect to the edit page.
    $path = sprintf('user/%d/edit', $user->uid);
    $_GET['destination'] = $path;
    drupal_goto($path);
  }

}

/**
 * Validates if the users using the bundle is already in the kms oci queue.
 *
 * @param array $form
 *   Drupal form array.
 * @param array $form_state
 *   Drupal form state array.
 */
function _kms_oci_queue_validate_job_blocker_bundle($form, &$form_state) {
  if (_kms_oci_queue_validate_job_blocker_bundle_is_blocked($form)) {
    form_set_error('submit', t('A job that shares users with this bundle is in the queue. Please wait until it has been executed.'));
    // GST wants form to be reset and reflect what is stored in drupal.
    // So we redirect to the edit page.
    $node = $form['#node'];
    $path = sprintf('node/%d/edit', $node->nid);
    $_GET['destination'] = $path;
    drupal_goto($path);
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function kms_oci_queue_form_user_profile_form_alter(&$form, &$form_state, $form_id) {
  if (_kms_oci_queue_validate_job_blocker_user_is_blocked($form)) {
    drupal_set_message(
      t('A job with same user is in the queue. Please wait until it has been executed.'),
      'warning',
      FALSE
    );
  }
  array_unshift($form['#validate'], '_kms_oci_queue_validate_job_blocker_user');
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function kms_oci_queue_form_access_bundle_node_form_alter(&$form, &$form_state, $form_id) {
  if (_kms_oci_queue_validate_job_blocker_bundle_is_blocked($form)) {
    drupal_set_message(
      t('A job that shares users with this bundle is in the queue. Please wait until it has been executed.'),
      'warning',
      FALSE
    );
  }
  array_unshift($form['#validate'], '_kms_oci_queue_validate_job_blocker_bundle');
}

/**
 * Is the current bundle blocked or not.
 *
 * @param array $form
 *   Drupal form array.
 *
 * @return bool
 *   Is the current bundle blocked or not?
 */
function _kms_oci_queue_validate_job_blocker_bundle_is_blocked($form) {
  module_load_include('inc', 'kms_oci_queue', 'includes/kms_oci_queue_job_blocker');
  $node = $form['#node'];
  if (!empty($node->nid)) {
    $uids = _kms_permissions_get_uids_by_bids(array($node->nid));
    return kmsOciQueueJobBlocker::usersAreBlocked($uids);
  }
  return FALSE;
}

/**
 * Is the current bundle blocked or not.
 *
 * @param array $form
 *   Drupal form array.
 *
 * @return bool
 *   Is the current bundle blocked or not?
 */
function _kms_oci_queue_validate_job_blocker_user_is_blocked($form) {
  module_load_include('inc', 'kms_oci_queue', 'includes/kms_oci_queue_job_blocker');
  $user = $form['#user'];
  if (!empty($user->uid)) {
    return KmsOciQueueJobBlocker::userIsBlocked($user->uid);
  }
  return FALSE;
}

/**
 * Implements hook_views_bulk_operations_form_alter().
 */
function kms_oci_queue_views_bulk_operations_form_alter(&$form, &$form_state, $vbo) {
  if (empty($form_state['values']) || !isset($form_state['values']['select_all'])) {
    return;
  }

  $values = $form_state['values'];
  $operations = array(
    'action::kms_user_vbo_add_access_bundles',
    'action::kms_user_vbo_clear_access_bundles',
    'action::kms_permissions_vbo_clone_user_perms',
  );
  $steps = array(
    'views_bulk_operations_confirm_form',
    'views_bulk_operations_config_form',
  );

  if ($values['select_all']) {
    $uids = _kms_permissions_get_all_users();
  }
  else {
    $uids = array_filter($values['views_bulk_operations']);
  }

  if (
    in_array($form_state['step'], $steps)
      && in_array($values['operation'], $operations)
        && KmsOciQueueJobBlocker::usersAreBlocked($uids)
  ) {
    $destination = drupal_get_destination();
    drupal_set_message(
      t(
        'A job that shares users with action. Please wait until it has been executed. Go !back.',
        array('!back' => l(t('back'), $destination['destination']))
      ),
      'warning'
    );
    foreach (element_children($form) as $key) {
      if (!in_array($key, array('show_view_elements'))) {
        unset($form[$key]);
      }
    }
  }

}